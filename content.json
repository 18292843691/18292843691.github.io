{"meta":{"title":"dayDream's blog","subtitle":null,"description":"那些一起做的白日梦，你还记得么","author":"白日梦想家","url":"http:\\\\hexin.life"},"pages":[{"title":"","date":"2017-04-01T07:32:40.978Z","updated":"2017-04-01T07:32:23.109Z","comments":true,"path":"404.html","permalink":"http:\\\\hexin.life/404.html","excerpt":"","text":""},{"title":"archives:","date":"2017-04-06T09:49:42.000Z","updated":"2017-07-17T14:50:10.728Z","comments":false,"path":"archives/index.html","permalink":"http:\\\\hexin.life/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-06T09:47:38.000Z","updated":"2017-04-15T14:22:38.194Z","comments":false,"path":"tags/index.html","permalink":"http:\\\\hexin.life/tags/index.html","excerpt":"","text":""},{"title":"categories:","date":"2017-04-06T09:49:42.000Z","updated":"2017-04-15T14:22:30.057Z","comments":false,"path":"categories/index.html","permalink":"http:\\\\hexin.life/categories/index.html","excerpt":"","text":""},{"title":"console.log(aboutme)","date":"2017-10-11T17:23:43.046Z","updated":"2017-10-11T17:23:43.046Z","comments":false,"path":"about/index.html","permalink":"http:\\\\hexin.life/about/index.html","excerpt":"","text":"#content-1{ width: 100%; height: 100%; padding: 0; margin: 0; position: relative; } #aboutme { width: 450px; height: 250px; /*background: url(yy.jpg) no-repeat -5px -120px;*/ margin: 130px auto; border: 4px solid rgba(245, 245, 245, .8); box-shadow: 0 1px 5px rgba(0, 0, 0, .1), 0 1px 10px rgba(0, 0, 0, .4) inset; position: relative; cursor: pointer; background-color: #fff; padding: 15px; border-radius: 5px; } #aboutme img{ width: 100%; height: 100%; /*border: 4px solid rgba(245, 245, 245, .8);*/ box-shadow: 0 1px 10px rgba(0, 0, 0, .4) inset; } @media screen and(max-width:775px){ .aboutme{ width: 288px; height: 200px; } } #aboutme:before { content: \"\"; position: absolute; background: transparent; z-index: -10; top: 15px; bottom: 10px; right: 20px; left: 20px; transform: skewX(10deg); box-shadow: 0 0 25px rgba(0, 0, 0, .5); border-radius: 15px; } #aboutme:after{ content: \"\"; position: absolute; background: transparent; z-index: -10; top: 50% ; bottom: 70px; right: -10px; left: 20px; transform: rotateZ(20deg); box-shadow: 0 0 30px rgba(0, 0, 0, .4); border-radius: 40px; } #canvas-clock{ position: absolute; bottom: 3px; right: 3px; } function Aboutme(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } function Resume(name, age, sex, email) { Aboutme.call(this, name, age, sex); this.email = email; } Resume.prototype = Object.create(Aboutme.prototype); Resume.prototype.constructor = Resume; var email = \"hexin_9508@163.com\"; var skills = { HTML: \"familliar\", CSS: \"familliar\", JavaScript: \"familliar\", ES6: 'learning', Vue: 'learning' } // var projects = { // blog:\"http://hexin.life\", // More:\"watting\" // } var hexin = new Resume(\"hexin\",\"22\",\"♂\",email); hexin.DesiredJob = \"Front-end engineer\"; hexin.current = \"student 2014-2018 in xi'an UFE\"; hexin.Hobby = \"coding,Basketball,古风音乐,E-Sports\"; hexin.tel = \"18292843691\"; //hexin.tel = \"18292843691\"; hexin.blog = 'http://hexin.life'; hexin.Github = 'https://github.com/18292843691'; hexin.skills = skills; // hexin.project = projects; for (var i in hexin) { if (hexin.hasOwnProperty(i)) { if ((typeof hexin[i]) == \"object\") { console.log(i + \":\"); for (var j in hexin[i]) { console.log(\" \" + j + \":\", hexin[i][j]); } } else { console.log(i + \":\", hexin[i]); } } } // 时钟 var clo = document.getElementById('clock'); var ctx = clo.getContext('2d'); var width = ctx.canvas.width; //获取canvas的宽度 var height = ctx.canvas.height; //获取canvas的高度 var r = width*0.8/2; //圆的半径 var rem = width*0.8 / 205; //方便调整时钟大小 function drawBackground() { //画最外圈的圆 ctx.save(); //状态保存 ctx.translate(r,r); //将原点0,0移到r,r ctx.beginPath(); ctx.lineWidth = 5 * rem; ctx.arc(0,0,r-3,0,2*Math.PI); ctx.stroke(); //ctx.fill(); //小时 var hourNumber = [3,4,5,6,7,8,9,10,11,12,1,2]; //数组保存小时 ctx.font= 20 * rem +\"px Arial\"; ctx.textAlign = 'center'; //居中显示 ctx.textBaseline = 'middle'; hourNumber.forEach(function(number,i){ //将12小时显示在正确位置 //弧度 var rad = 2 * Math.PI / 12 *i; var x = Math.cos(rad) * (r - (25 * rem)); var y = Math.sin(rad) * (r - (25 * rem)); ctx.fillText(number,x,y); }); for(var i =0 ; i"},{"title":"","date":"2017-07-30T11:51:56.137Z","updated":"2017-07-30T11:43:14.535Z","comments":false,"path":"more/flex圣杯.html","permalink":"http:\\\\hexin.life/more/flex圣杯.html","excerpt":"","text":"Document body,html { padding: 0; margin: 0; } .all{ display: flex; flex-direction: column; } header,footer{ flex: 1 0 auto; background-color: rgba(0,0,0,.4); height: 100px; } .container { display: flex; /* flex: 3; */ /* 一共分为三份 */ flex-direction: row; /* 水平正向排列 */ } /* 左右俩份，当屏幕缩小时，不缩小 */ .left,.right{ flex: 0 0 200px; /*flex: x => {默认为0,有剩余空间不放大} 1 => {默认为为1，空间不足缩小} size => {默认 auto ,占据固定空间}*/ background-color: blue; height: 200px; } .center{ flex: 1; height: 200px; background-color: red; } header left center right footer"},{"title":"","date":"2017-07-30T11:51:56.137Z","updated":"2017-07-30T11:13:13.860Z","comments":false,"path":"more/js-test-1.html","permalink":"http:\\\\hexin.life/more/js-test-1.html","excerpt":"","text":"Document (function() { let body = document.body; for (let i = 0; i < 10; i++) { let a = document.createElement('a'); a.textContent = `${i}`; a.style.cssText = 'margin: 5px;' + 'color: #363636;' + 'font-size: 16px'; body.appendChild(a); } let ac = document.getElementsByTagName('a'); //console.log(ac) for (let i = 0; i < 10; i++) { ac[i].onclick = function() { alert(i) } // ac[i].addEventListener('click', function() { // alert(ac[i].textContent) // }) } // 数组随机排序 var arr = [11, 22, 33, 44, 55, 66, 77, 88, 99, 100]; let len = arr.length; function RandomArray(arr) { if (arr.length == 1) { return arr; } for (let i = 0; i < len; i++) { let random = Math.floor(Math.random() * len); arr.push(arr[random]); arr.splice(random, 1); } console.log(arr); return arr; } RandomArray(arr); })()"},{"title":"","date":"2017-07-30T11:51:56.152Z","updated":"2017-07-30T11:08:49.892Z","comments":false,"path":"more/linkage.html","permalink":"http:\\\\hexin.life/more/linkage.html","excerpt":"","text":"联动 body, html { height: 100%; width: 100%; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; } .container { display: flex; width: 600px; height: 200px; border: 1px solid rgba(200, 200, 200, .8); justify-content: center; align-items: center; border-radius: 50px; /*flex-flow: column;*/ /*padding: 10px;*/ flex-direction: column; } .hide { display: none; } .show { display: show; } select { width: 120px; height: 25px; overflow: scroll; } .category { margin: 20px 20px 20px -40px; } .category input { margin-left: 80px; } .pretty { float: left; margin-left: -20px; } .pretty select { margin-left: 40px; } 学校 工作单位 北 北京 西安 浙江 上海 北京大学 清华大学 美团 饿了么 const cities = []; const university = [ ['beiUFE', 'beiSchool'], ['北京大学', '清华大学'], ['西安大学', '西安西安', '西安阿里'], ['浙江大学', '浙江阿里'], ['上海戏剧学院', '上海美剧'] ]; const companies = [ ['滴滴'], ['美团', '饿了么'], ['阿里'], ['京东'], ['nothing', 'i dont know'] ]; const category = document.querySelectorAll('.category input'); const student = document.querySelector('.student'); const worker = document.querySelector('.worker'); const school = document.querySelector('#school'); const city = document.querySelector('#city'); const workk = document.querySelector('#work'); category.forEach(function(input, index) { //console.log(input) input.addEventListener('click', function() { if (index == 0) { student.classList.remove('hide'); worker.classList.add('hide'); } else { student.classList.add('hide'); worker.classList.remove('hide'); } }, false) }) city.addEventListener('change', function() { const index = parseInt(city.value); if (student.className === 'student') { school.innerHTML = ''; var html = ''; for (let i = 0, len = university[index].length; i < len; i++) { // console.log(`${university[index][i]}`) html += `${university[index][i]}`; } school.innerHTML = html; } if (worker.className === 'worker') { workk.innerHTML = ''; var html = ''; for (let i = 0, len = companies[index].length; i < len; i++) { console.log(`${companies[index][i]}`) html += `${companies[index][i]}`; } workk.innerHTML = html; } }, false)"},{"title":"","date":"2017-07-30T11:51:56.168Z","updated":"2017-07-30T11:08:56.624Z","comments":false,"path":"more/mangnifyLens.html","permalink":"http:\\\\hexin.life/more/mangnifyLens.html","excerpt":"","text":"Document html,body{ padding: 0; margin: 0; } #demo{ display: block; width: 400px; height: 255px;; margin: 50px; position: relative; } #sm-box{ position: relative; z-index: 1; width:400px; height: 255px; display: block; border: 1px solid #ccc; overflow: hidden; cursor: move; } #bg-box{ display: none; position: absolute; top:0; left: 500px; width: 400px; height: 300px; overflow: hidden; border: 1px solid #ccc; z-index: 1; } #bg-box img{ position: absolute; z-index: 5; } #float-box{ display: none; width: 150px; height: 150px; background-color: rgba(0,0,0,.3); border: 1px solid #ccc; cursor: move; position: absolute; } #mark { position: absolute; display: block; width: 400px; height: 255px; background-color: rgba(0,0,0,0); z-index: 2; } window.onload = function () { var demo = document.getElementById('demo'), smBox = document.getElementById('sm-box'), bgBox = document.getElementById('bg-box'), mark = document.getElementById('mark'), floatBox = document.getElementById('float-box'); var bigBoxImage = bgBox.getElementsByTagName('img')[0]; smBox.onmouseover = function (e) { // if(e.stopPropagation){ // e.stopPropagation(); // } else { // e.cancelBubble(); // } floatBox.style.display = 'block'; bgBox.style.display = 'block'; } smBox.onmouseout = function (e) { // if(e.stopPropagation){ // e.stopPropagation(); // } else { // e.cancelBubble(); // } floatBox.style.display = 'none'; bgBox.style.display = 'none'; } smBox.onmousemove = function (e) { var _event = e || window.event; var left = _event.clientX - (demo.offsetLeft + smBox.offsetLeft + (floatBox.offsetWidth) / 2 ); var top = _event.clientY - (demo.offsetTop + smBox.offsetTop + (floatBox.offsetHeight) / 2); floatBox.style.left = left + 'px'; floatBox.style.top = top + 'px'; if (left < 0) { left = 0; } else if (left > smBox.offsetWidth - floatBox.offsetWidth) { left = smBox.offsetWidth - floatBox.offsetWidth; } if (top < 0) { top = 0; } else if (top > smBox.offsetHeight - floatBox.offsetHeight) { top = smBox.offsetHeight - floatBox.offsetHeight; } var preX = left / (smBox.offsetWidth - floatBox.offsetWidth); var preY = top / (smBox.offsetHeight - floatBox.offsetHeight); bigBoxImage.style.left = -preX * (bigBoxImage.offsetWidth - bgBox.offsetWidth) + 'px'; bigBoxImage.style.top = -preY * (bigBoxImage.offsetHeight - bgBox.offsetHeight) + 'px'; } }"},{"title":"","date":"2017-08-20T15:08:07.460Z","updated":"2017-08-20T15:08:07.460Z","comments":true,"path":"more/双飞翼布局--三列中间自适应.html","permalink":"http:\\\\hexin.life/more/双飞翼布局--三列中间自适应.html","excerpt":"","text":"Document body,html{ margin: 0; padding: 0; width: 100%; } .left { position: relative; width: 200px; height: 300px; float: left; margin-right: -200px; background-color: #ccc; } .right{ position: relative; width: 200px; height: 300px; float: right; margin-left: -200px; background: red; } .main{ width: 100%; float: left; background-color: blue; height: 300px; } .center{ margin: 0 200px 0 200px; } 左侧定宽 中间自适应 右侧定宽"},{"title":"","date":"2017-08-04T11:53:36.865Z","updated":"2017-08-04T11:53:36.865Z","comments":true,"path":"more/pdd.html","permalink":"http:\\\\hexin.life/more/pdd.html","excerpt":"","text":"Document .mark { color: red; } .loader { overflow: hidden; position: relative; z-index: 99; width: 120px; height: 120px; line-height: 120px; } .loader p { font-size: 16px; text-align: center; padding-top: 20px; } .loader-inner { bottom: 0; height: 60px; left: 0; margin: auto; position: absolute; right: 0; top: 0; width: 100px; } .loader-line-wrap { animation: spin 2000ms cubic-bezier(.175, .885, .32, 1.275) infinite ; box-sizing: border-box; height: 50px; left: 0; overflow: hidden; position: absolute; top: 0; transform-origin: 50% 100%; width: 100px; } .loader-line { border: 4px solid transparent; border-radius: 100%; box-sizing: border-box; height: 100px; left: 0; margin: 0 auto; position: absolute; right: 0; top: 0; width: 100px; } .loader-line-wrap:nth-child(1) { animation-delay: -50ms; } .loader-line-wrap:nth-child(2) { animation-delay: -100ms; } .loader-line-wrap:nth-child(3) { animation-delay: -150ms; } .loader-line-wrap:nth-child(4) { animation-delay: -200ms; } .loader-line-wrap:nth-child(5) { animation-delay: -250ms; } .loader-line-wrap:nth-child(1) .loader-line { border-color: hsl(0, 80%, 60%); height: 90px; width: 90px; top: 7px; } .loader-line-wrap:nth-child(2) .loader-line { border-color: hsl(60, 80%, 60%); height: 76px; width: 76px; top: 14px; } .loader-line-wrap:nth-child(3) .loader-line { border-color: hsl(120, 80%, 60%); height: 62px; width: 62px; top: 21px; } .loader-line-wrap:nth-child(4) .loader-line { border-color: hsl(180, 80%, 60%); height: 48px; width: 48px; top: 28px; } .loader-line-wrap:nth-child(5) .loader-line { border-color: hsl(240, 80%, 60%); height: 34px; width: 34px; top: 35px; } @keyframes spin { 0%, 15% { transform: rotate(0); } 100% { transform: rotate(360deg); } } baidu function createElement() { var body = document.body; var fragment = document.createDocumentFragment() var div = document.createElement('div') div.setAttribute('id', 'hello') fragment.appendChild(div) var p = document.createElement('p') p.className = 'textToMark' p.innerHTML = 'hdslakddnska8das' div.appendChild(p); body.appendChild(fragment) } createElement(); /************************************************/ const textToMark = document.querySelector('.textToMark'); const text = textToMark.innerHTML; const reg = /[da\\*8]+/g; var newtext = text.replace(reg, (match) => { return match = `${match}`; }); textToMark.innerHTML = newtext; /---------------------------------------------------------/ // const arr = ['d', 'a', '*', '8']; // const newText = text.split(''); // function toMark (textArr, arr) { // for(let i = 0; i < newText.length; i++) { // for(let j = 0; j < arr.length; j++) { // if(newText[i] == arr[j]) { // newText[i] = `${newText[i]}`; // } // } // } // return newText; // } // toMark(newText, arr); // textToMark.innerHTML = newText.join(''); function valueToCopy(valueBeCopy) { var copyValue; if (typeof(+valueBeCopy) === 'number' && typeof valueBeCopy !== 'object') { copyValue = +valueBeCopy; } else if (typeof valueBeCopy === 'string') { copyValue = parseInt(+copyValue); } else if (typeof valueBeCopy === 'object') { if (Array.isArray(valueBeCopy)) { copyValue = valueBeCopy.slice(); } copyValue = JSON.parse(JSON.stringify(valueBeCopy)) } copyValue = valueBeCopy; // console.log(copyValue) return copyValue; } var arr = [1, 2, 3, 4, 5, '6', 'a', 'b']; var obj = { a: 'a', b: 'b', c: { ac: 'ac', ab: 'ab', ac: { aca: 'aca' } } }; var booleanTrue = true; var booleanFalse = false; var num = 987654321; var strNum = '123456789'; var strStr = 'asdfghjkl'; function fun() { console.log('hello') }; valueToCopy(arr); valueToCopy(obj); valueToCopy(booleanFalse); valueToCopy(booleanTrue); valueToCopy(num); valueToCopy(strNum); valueToCopy(strStr); valueToCopy(fun); /***************************************************/ var aa = document.getElementById('cls') aa.onmouseup = function(e) { // console.log(e) e.preventDefault() } aa.onmousedown = function(e) { e.preventDefault() } aa.onclick = function(e) { e.preventDefault() } /*****************************************************/ var input = document.getElementById('ipt') input.onmouseup = function() { console.log('onmouseup') } input.onmousedown = function() { console.log('onmousedown') } input.onclick = function() { console.log('onclick') } input.onfocus = function() { console.log('onfocus') } /**************************************************/ function one () { this.name = 1; return function two () { name = 2; return function three() { var name = 3; console.log(this.name); } } } one()()()"},{"title":"","date":"2017-08-20T14:47:29.457Z","updated":"2017-08-20T14:47:29.457Z","comments":false,"path":"more/圣杯.html","permalink":"http:\\\\hexin.life/more/圣杯.html","excerpt":"","text":"Document body,html { padding: 0; margin: 0; } .container { margin-right: 200px; margin-left: 200px; } .left,.center,.right{ height: 300px; position: relative; float: left; } .left{ width: 200px; right: 200px; margin-left: -100%; background-color: #ccc; } .center{ width: 100%; background-color: red; } .right{ width: 200px; margin-right: -200px; background-color: blue; } center left right"},{"title":"","date":"2017-08-02T13:33:55.871Z","updated":"2017-08-02T13:33:55.871Z","comments":true,"path":"more/字符串模板(1).js","permalink":"http:\\\\hexin.life/more/字符串模板(1).js","excerpt":"","text":"function ren (str, data) { var reg = /\\$\\{(.+?)\\}/g; while (match = reg.exec(str)) { str = str.replace(match[0], data[match[1]]) } return str; } var str = 'hello ${obj}, i am ${name}, i am going to ${thing}'; var hexin = { name: 'hexin', obj: 'world', thing: 'to walk' } ren(str, hexin)"},{"title":"","date":"2017-08-20T15:13:29.020Z","updated":"2017-08-20T15:13:29.020Z","comments":true,"path":"more/布局.html","permalink":"http:\\\\hexin.life/more/布局.html","excerpt":"","text":"Document body, html { padding: 0; margin: 0; min-width: 700px; } .layout { margin-top: 20px; } .layout article div { min-height: 100px; } .container4, .container5 { margin-top: 20px; height: 100px; } /* 圣杯布局 */ .container4 { margin-left: 300px; margin-right: 300px; } .left4, .right4, .center4 { float: left; position: relative; height: 100px; } .left4 { width: 300px; right: 300px; margin-left: -100%; background-color: red; } .center4 { width: 100%; background: green; } .right4 { width: 300px; margin-left: -300px; left: 300px; background: blue; } /* 双飞翼 */ .main5 { float: left; width: 100%; } .center5 { height: 100px; margin-left: 300px; margin-right: 300px; background-color: green; } .left5 { float: left; width: 300px; height: 100px; margin-left: -100%; background-color: red; } .right5 { float: left; width: 300px; height: 100px; margin-left: -300px; background-color: blue; } /* flex 布局*/ .container6 { display: flex; flex-direction: row; } .right6, .left6 { flex: 0 0 300px; height: 100px; background: blue; } .center6 { flex: 1; height: 100px; background: red; } 圣杯布局 left4 right4 双飞翼 left5 right5 .layout.float .left { float: left; width: 300px; background: red; } .layout.float .right { float: right; width: 300px; background: blue; } .layout.float .center { background: green; } 浮动解决方案 .layout.absolute .left-center-right>div { position: absolute; } .layout.absolute .left { left: 0; width: 300px; background: red; } .layout.absolute .center { left: 300px; right: 300px; background: green; } .layout.absolute .right { right: 0; width: 300px; background: blue; } 绝对定位 .layout.flexbox .left-center-right { margin-top: 140px; display: flex; } .layout.flexbox .left { flex: 0 0 300px; background: red; } .layout.flexbox .center { flex: 1; background: green; } .layout.flexbox .right { flex: 0 0 300px; background: blue; } flex 布局 .layout.table .left-center-right { width: 100%; display: table; height: 100px; } .layout.table .left-center-right>div { display: table-cell; } .layout.table .left { width: 300px; background: red; } .layout.table .center { background: green; } .layout.table .right { width: 300px; background: blue; } 表格布局 .layout.grid .left-center-right { display: grid; /* 网格宽度 */ width: 100%; /* 行高 */ grid-template-rows: 100px; /* 3列 */ grid-template-columns: 300px auto 300px; /* 左:300 , 中:自动, 右:300 */ } .layout.grid .left { background: red; } .layout.grid .center { background: green; } .layout.grid .right { background: blue; } 网格布局"},{"title":"","date":"2017-08-22T16:44:01.722Z","updated":"2017-08-22T16:44:01.722Z","comments":true,"path":"more/用div制作textarea.html","permalink":"http:\\\\hexin.life/more/用div制作textarea.html","excerpt":"","text":"Document .div-text{ min-height: 20px; min-width: 80px; } .div-text{ margin: 50px; padding-left: 3px; width: 100px; border: 1px solid #ccc; resize: both; overflow: hidden; } i am div i am div too hello var input = document.getElementById('cls') // Input 按下的触发 input.onmouseup = function() { console.log('onmouseup') } input.onmousedown = function() { console.log('onmousedown') } input.onclick = function() { console.log('onclick') } input.onfocus = function() { console.log('onfocus') } // dom 的建立与添加 var div = document.querySelector('.come'); var p1 = document.createElement('p') p1.innerHTML = 'p1' p1.className = 'p1' div.appendChild(p1) var p2 = document.createElement('p') p2.innerHTML = 'p2' p2.classList.add('p2'); div.appendChild(p2) var p2c = document.querySelector('.p2'); // 事件冒泡 // p2c.addEventListener('click', function(e) { // e.stopPropagation() // alert('p2') // }) var body = document.body // 事件代理 // body.addEventListener('click', function(e) { // var target = e.target // // console.log(target.nodeName) // if(target.nodeName === 'P') { // alert(target.innerHTML) // } // }) // // div.addEventListener('click', function(e){ // console.log(e.path) 冒泡 // }) // 事件代理及事件绑定的封装 function bindEvent(elem, type, selector, fn) { if(fn == null) { fn = selector selector = null } elem.addEventListener(type, function(e) { var target if(selector) { // 代理 target = e.target if(target.matches(selector)) { fn.call(target, e) } } else { // 不是代理 fn(e) } }) } bindEvent(body, 'click', 'p', function(e) { console.log(this.innerHTML) }) bindEvent(p2c, 'click', function(e) { console.log(p2c.innerHTML) }) /**************************************/ function SortCard (n, k, arr) { let arrTmp = []; sort(n, arr, arrTmp); while(--k > 0){ SortCard(n, k--, arrTmp) k--; } arrTmp = arrTmp.reverse().join(' '); console.log(arrTmp) return arrTmp } function sort (n, arr, arrTmp) { let arr1 = [], arr2 = []; arr1 = arr.slice(0, n); arr2 = arr.slice(n, arr.length); while (arr1.length !== 0 || arr2.length !== 0) { arrTmp.push(arr2.pop()) arrTmp.push(arr1.pop()) } return arrTmp } var arr = [1, 2, 3, 4, 5, 6] SortCard(3, 4, arr)"}],"posts":[{"title":"JavaScript 的数组(未整理)","slug":"title-31","date":"2017-10-10T16:23:50.000Z","updated":"2017-10-10T16:36:22.451Z","comments":true,"path":"2017/10/11/title-31/","link":"","permalink":"http:\\\\hexin.life/2017/10/11/title-31/","excerpt":"","text":"js 数组 数组是类似列表的对象，在原型中提供了遍历以及改变其中元素的很多方法。 数组的长度及其中元素的类型都是不固定的。因为数组的长度可读可写，有时数组中的元素也不是在连续的位置，所以JavaScript 数组不一定是密集的。通常情况下，这是一些方便的特性；如果这些特性不适用于你的特定使用场景，你可以考虑使用固定类型数组。 向 Array 构造函数传入一个在 0 到 2^32-1 之间的整数，将返回一个以此为长度的数组对象。通过 length 属性可以访问这个值。如果传入的参数不是有效的数值，则抛出 RangeError 异常。 12345678arr = [1,2,3]arr[1] === arr[&apos;1&apos;] // arr[01] === arr[&apos;1&apos;]// truearr[01] === arr[&apos;01&apos;]// false1 会被 Javascript 引擎自动调用 toString 转换成一个 string 类型的变量 当你在 array 上使用一个合法的数组下标，而且该下标超出了当前数组的大小的时候，引擎会根据其值自动更新 array 的length属性 减小 array 的length属性会删掉超出的元素 使用正则匹配的结果来创建数组正则表达式与字符串之间的匹配结果可以创建一个数组。这个数组包含了正则匹配的属性与匹配结果。 RegExp.exec ， String.match ， 与 String.replace 的返回值就是这样的数组。下面的例子可以帮助理解这些属性和元素。 1234567// Match one d followed by one or more b&apos;s followed by one d// Remember matched b&apos;s and the following d// 忽略大小写myRe = /d(b+)(d)/i;myArray = myRe.exec(&quot;cdbBdbsbz&quot;);// [&quot;dbBd&quot;, &quot;bB&quot;, &quot;d&quot;, index: 1, input: &quot;cdbBdbsbz&quot;] 该正则匹配返回的属性/元素列表： 123456Property/Element 说明 例子input 原始的输入字符串，只读属性。 cdbBdbsbzindex 匹配的子字符串的第一个字符在原始字符串中的位置（从0开始的索引，只读）。 1[0] 最后一次匹配的元素,只读。 dbBd[1], ...[n] 出现在正则匹配中的子匹配（如果有）。 [1]: bB [2]: d 方法: For methods available on Array instances, see Methods of Array instances. Array.from()从类数组或者迭代对象（iterable object）中创建一个新的数组实例。 Array.isArray()假如一个变量是数组则返回true，否则返回false。 数组实例所有数组实例继承自 Array.prototype。Array 构造函数的原型对象是可修改的，其会影响所有的数组实例。 属性 Array.prototype.constructor所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。 Array.prototype.length因为 Array.prototype 也是个数组，所以它也有 length 属性，这个值为 0，因为它是个空数组 方法 Mutator 方法下面的这些方法会改变调用它们的对象自身的值： Array.prototype.copyWithin()在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。 Array.prototype.fill()将数组中指定区间的所有元素的值，都替换成某个固定的值。 Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。 Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。 Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 Array.prototype.shift()删除数组的第一个元素，并返回这个元素。 Array.prototype.sort() =&gt; v8 中，对于长度小于 22 的数组进行插入排序， 大于 22 的数组进行快速排序对数组元素进行排序，并返回当前数组。 Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。 Accessor 方法下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 Array.prototype.includes()判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 Array.prototype.join()连接所有数组元素组成一个字符串。 Array.prototype.slice()抽取当前数组中的一段元素组合成一个新数组。 Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 Array.prototype.toLocaleString()返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。 Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Iteration 方法 * 代表处于实验阶段在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在回调函数执行之前，数组的长度会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。 Array.prototype.entries() *返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。 Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find() *找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 Array.prototype.findIndex() *找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys() *返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。 Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.reduceRight()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values() *返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。 Array.prototype@@iterator *和上面的 values() 方法是同一个函数。 识别数组123456789// Array.isArray(arr)Array.prototype._isArray1 = function () &#123; return typeof arr === &apos;object&apos; &amp;&amp; arr.constructor === Array;&#125;Array.prototype._isArray2 = function () &#123; return Object.prototype.toString.call(arr).slice(8, 13) === &apos;Array&apos;&#125; 构建 m * n 维矩阵 初始化 x;1234567891011121314Array.mate = function (m, n, x) &#123; var a, i, j, res = []; for(i = 0; i &lt; m; i++) &#123; a = []; for(j = 0; j &lt; n; j++) &#123; a[j] = x; &#125; res[i] = a; &#125; return res&#125; B 站笔试第二题，从 input 获取 N ，在页面内创建 N * N 的小方块，要求，小方块在鼠标放上时显示红色，离开时恢复，点击后显示蓝色，离开时不变，再次点击时恢复。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;body&gt;&lt;input type=&quot;number&quot; id=&quot;inp&quot; placeholder=&quot;input number and enter&quot;&gt;&lt;/body&gt;&lt;script&gt; (function () &#123; let inp = document.getElementById(&apos;inp&apos;), val; inp.addEventListener(&apos;keyup&apos;, function (e) &#123; if (e.keyCode === 13) &#123; val = inp.value; createEle(val); inp.value = &apos;&apos;; &#125; &#125;) function createEle (val) &#123; val = parseInt(val); if (val &gt; 0) &#123; if (document.querySelector(&apos;.uul&apos;)) &#123; document.body.removeChild(document.querySelector(&apos;.uul&apos;)); &#125; var dom = document.createDocumentFragment(), ul = document.createElement(&apos;ul&apos;); ul.className = &apos;uul&apos;; var array = [], body = document.body, div; for (let i = 0; i &lt; val; i++) &#123; for (let j = 0; j &lt; val; j++) &#123; div = document.createElement(&apos;li&apos;); div.className = &apos;blockItem&apos;; div.style.top = i * 25 + &apos;px&apos;; div.style.left = j * 25 + &apos;px&apos;; ul.appendChild(div); &#125; &#125; dom.appendChild(ul); //console.log(&apos;dom: &apos;+ dom); body.appendChild(dom); //var block = document.getElementsByClassName(&apos;blockItem&apos;); bindEvent(body); &#125; else &#123; inp.value = &apos;&apos;; console.log(&apos;you should input some number&apos;) //throw new Error(&apos;you should input some number&apos;) &#125; &#125; function bindEvent (body) &#123; body.addEventListener(&apos;mouseover&apos;, function(e) &#123; //console.log(&apos;mouseover li&apos;) if (e.target.nodeName === &apos;LI&apos;) &#123; if (e.target.style.background !== &apos;blue&apos;) e.target.style.background = &apos;red&apos;; &#125; &#125;) body.addEventListener(&apos;mouseout&apos;, function(e) &#123; //console.log(&apos;mouseout li&apos;) if (e.target.nodeName === &apos;LI&apos;) &#123; if (e.target.style.background !== &apos;blue&apos;) e.target.style.background = &apos;&apos;; &#125; &#125;) body.addEventListener(&apos;click&apos;, function(e) &#123; if (e.target.nodeName === &apos;LI&apos;) &#123; if (e.target.style.background !== &apos;blue&apos;)&#123; e.target.style.background = &apos;blue&apos;; &#125; else &#123; e.target.style.background = &apos;&apos;; &#125; &#125; &#125;) &#125; &#125;)()&lt;/script&gt;&lt;style&gt; .uul &#123; display: block; position: absolute; left: 300px; margin-left: 300px; &#125; .blockItem&#123; background: #ccc; list-style: none; position: absolute; &#125;&lt;/style&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http:\\\\hexin.life/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http:\\\\hexin.life/tags/JavaScript/"}]},{"title":"JS 二叉树的实现","slug":"title-30","date":"2017-10-10T16:22:03.000Z","updated":"2017-10-11T17:19:21.898Z","comments":true,"path":"2017/10/11/title-30/","link":"","permalink":"http:\\\\hexin.life/2017/10/11/title-30/","excerpt":"介绍一下，这是我的 0 offer","text":"介绍一下，这是我的 0 offer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275/** * 二叉树 */function BinaryTree () &#123; var Node = function (root)&#123; this.root = root; this.left = null; this.right = null; &#125; var root; this.insertNode = function (node) &#123; var newNode = new Node(node); if (root == null) &#123; root = newNode; &#125; else &#123; insert(root, newNode) &#125; this.root = root; &#125; var insert = function (node, newNode) &#123; if (node.root &lt; newNode.root) &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insert(node.right, newNode) &#125; &#125; else &#123; if(node.left === null) &#123; node.left = newNode; &#125; else &#123; insert(node.left, newNode) &#125; &#125; &#125; this.removeNode = function (value) &#123; if (!value) return null; remove(root, value) &#125; var remove = function (root, value) &#123; if (root &amp;&amp; root.root &amp;&amp; root.right &amp;&amp; root.left) &#123; if (value === root.root)&#123; root.left = null; root.right = null; root.root = null; root = null; // console.log(&apos;clear&apos;, root) return root; &#125; &#125; if (root) &#123; if (value &lt; root.root) &#123; root.left = remove(root.left, value) return root; &#125; else if (value &gt; root.root) &#123; root.right = remove(root.right, value) return root; &#125; else &#123; if (!root.left &amp;&amp; !root.right) &#123; root = null; return root; &#125; if (root.left === null) &#123; root = root.right; return root; &#125; else if (root.right === null) &#123; root = root.left; return root; &#125; &#125; &#125; return null; &#125; // 清空树 this.clear = function () &#123; root.left = null; root.right = null; root.root = null; root = null; return root; &#125; // 回调打印 var print = function (value) &#123; console.log(&apos;::&apos;, value); &#125; // 中序遍历 this.inOrderTraverse = function () &#123; inOrderTraverseNode(root, print) &#125; var inOrderTraverseNode = function (node, print) &#123; if (node !== null) &#123; inOrderTraverseNode(node.left, print); print(node.root); inOrderTraverseNode(node.right, print); &#125; &#125; // 前序遍历 this.preOrderTraverse = function () &#123; preOrderTraverseNode(root, print); &#125; var preOrderTraverseNode = function (node, print) &#123; if (node !== null ) &#123; print(node.root); preOrderTraverseNode(node.left, print) preOrderTraverseNode(node.right, print) &#125; &#125; // 后序遍历 this.postOrderTraverse = function () &#123; postOrderTraverseNode(root, print); &#125; var postOrderTraverseNode = function (node, print) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, print) postOrderTraverseNode(node.right, print) print(node.root) &#125; &#125; // 按层遍历 this.floorOederTraverseNode = function () &#123; return floorTree(root); &#125; var floorTree = function (root) &#123; var queue = []; queue.push(root); if (root) &#123; if (root.left !== null) &#123; queue.push(root.left); &#125; if (root.right !== null) &#123; queue.push(root.right); &#125; &#125; var treeNode = []; while (queue.length &gt; 0) &#123; nod = queue.shift(); treeNode.push(nod); if (nod.left) &#123; queue.push(nod.left); &#125; if (nod.right) &#123; queue.push(nod.right); &#125; // console.log(queue) &#125; treeNode = treeNode.map(function(value) &#123; return value = value.root; &#125;); return Array.from(new Set(treeNode)); &#125; // 打印最小值 this.minNode = function () &#123; return min(root) &#125; var min = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.root; &#125; return null; &#125; // 打印最大值 this.maxNode = function () &#123; return max(root) &#125; var max = function (node) &#123; if (node) &#123; while (node &amp;&amp; node.right !== null) &#123; node = node.right &#125; return node.root; &#125; return null; &#125; // 打印树高度 this.treeHeight = function () &#123; return findHeight(root); &#125; function findHeight (root) &#123; var height = 0; if (root) &#123; if (root.right || root.left) &#123; height++; findHeight(root.right); &#125; &#125; return height; &#125; // 寻找值 this.findNode = function (value) &#123; return find(root, value) &#125; var find = function (root, value) &#123; if(root &amp;&amp; root.root) &#123; if (value &lt; root.root) &#123; return find(root.left, value) &#125; else if (value &gt; root.root) &#123; return find(root.right, value) &#125; else &#123; console.log(&apos;root is: &apos;, root); return true; &#125; &#125; return false; &#125; // 打印第 k 层节点 this.printKTree = function (k) &#123; if (root) &#123; if (k == 0) &#123; console.log(&apos;root&apos;, root.root); &#125; else if (k === 1)&#123; findLeftChild(root, k); &#125; else &#123; findLeftChild(root, k); findRightChild(root, k); &#125; &#125; &#125; var findLeftChild = function (root, k) &#123; if (k - 1 == 0 &amp;&amp; root &amp;&amp; root.right &amp;&amp; root.left) &#123; console.log(root.left.root, root.right.root) &#125; if (root) &#123; findLeftChild(root.left, --k); &#125; &#125; var findRightChild = function (root, k) &#123; if (k - 1 == 0 &amp;&amp; root &amp;&amp; root.right &amp;&amp; root.left) &#123; console.log(root.left.root, root.right.root) &#125; if (root) &#123; findRightChild(root.right, --k); &#125; &#125;&#125;var nodes = [6, 4 , 5, 2, 1, 3, 8, 7, 10, 9, 11];var binaryTree = new BinaryTree();nodes.forEach((value) =&gt; &#123; binaryTree.insertNode(value)&#125;);// binaryTree.inOrderTraverse()// binaryTree.preOrderTraverse()// binaryTree.postOrderTraverse()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http:\\\\hexin.life/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http:\\\\hexin.life/tags/JavaScript/"}]},{"title":"JS 实现单链表","slug":"title-29","date":"2017-10-10T16:20:38.000Z","updated":"2017-10-11T17:19:25.435Z","comments":true,"path":"2017/10/11/title-29/","link":"","permalink":"http:\\\\hexin.life/2017/10/11/title-29/","excerpt":"单链表的 JS 简单实现","text":"单链表的 JS 简单实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var lists = function () &#123; var List = function (head) &#123; this.data = head; this.next = null; &#125; var _head = new List(&apos;head&apos;); this.insertList = function (head) &#123; var newList = new List(head); insert(_head, newList) this.head = _head; &#125; // 头插法 function insert (head, newList) &#123; newList.next = head.next; head.next = newList; &#125; // 正序打印 this.print = function () &#123; head = Object.assign(&#123;&#125;, this.head); while(head.next) &#123; console.log(head.next.data); head.next = head.next.next; &#125; &#125; // 逆序输出 this.reverse = function () &#123; head = Object.assign(&#123;&#125;, this.head); var res = [] while(head.next) &#123; res.push(head.next); head.next = head.next.next; &#125; while (res.length &gt; 0) &#123; console.log(res.pop().data) &#125; &#125;&#125;var list = new lists();var nodes = [1,2,3,4,5,6,7];nodes.forEach((value) =&gt; &#123; list.insertList(value);&#125;)","categories":[],"tags":[]},{"title":"面试经历","slug":"title-27","date":"2017-10-09T17:07:49.000Z","updated":"2017-10-12T16:49:54.485Z","comments":true,"path":"2017/10/10/title-27/","link":"","permalink":"http:\\\\hexin.life/2017/10/10/title-27/","excerpt":"","text":"搜狗上来先做题 盒模型 布局，左边定宽，右边自适应~ 打印出页面所有 dom position 属性 relative 定位相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。 absolute 是根据什么定位的根据父级元素的 非 static 属性的元素 说一下你了解的前端? (wt?) 就是说你会些什么？ (wt?) meng !!! 说说 HTML5 新增？ CSS3 呢？ JavaScript 基础类型，值类型，引用类型。 原型链 =&gt; proto 和 prototype。 看你项目中用过 vue 和 jQuery，你哪个擅长一点 ? =&gt; 嘴贱说了 jQuery 你用过 JQuery ，你觉得 jQuery 的优点有哪些？ 你觉得不好或者自己觉得用的不舒服的或者你觉得可以改进的地方？ jQuery 的事件绑定是怎么实现的？ 看过 jQuery 源码吗？ =&gt; 没有~ =&gt; 还在用的阶段对吧？ =&gt; 对~ 说说 Vue 开发的好处吧~ Vue 双向绑定是怎么实现的。 没什么问问题了，你有什么要问我的吗？ 有什么是你准备了而他没问的吗？ =&gt; 看了好多知识，但是怕被他问住，就没说。 你看过什么书? 总结： 第一次面试 没怎么准备好，基本全程尬聊，在面试官的角度，他是想让我自己发挥出自己擅长的一面，自己说，然后他挑一些知识点来问，应该说挺专业的。但是我看面经的时候，一直以为是面试官一直问，我负责答，和我想象不太一样，看得出来面试官并没有提前准备面试题，看我不怎么会说，一直强行的想让我表现自己。只能怪自己知识体系太杂乱了，不知道怎么给面试官说。 西安葡萄城 闭包 -&gt; 写个例子 原型链 -&gt; 写个例子 用到了 call ， call 和 apply 的区别 打印第 k 层的二叉树结点 写了博客？博客是用什么建的？用什么语法写的？有没有了解背后的原理？ 有什么要问的吗？ 西安葡萄城二面 逆序单链表 二叉树 100 万个字符，要存储在磁盘中，但是现在磁盘容量不够了，要怎么才能存储进去，读取的时候可以正常读取使用？海量数据处理 总结： 比较久，一些问题记不清了，听说他们公司想招类似全栈的，问了好多数据结构，大数据处理的东西~答得比较渣 富途 四六级 数学成绩 C / C++ 成绩 逻辑题 1 -&gt; 三个盒子，分别为好盒子，坏盒子，混合盒子，内容装的都是正确的，但是发现盒子的标签全部贴错了,现在只能有一次检测机会，将标签正确的贴回去。 逻辑题 2 -&gt; 15 张牌，每人可以拿 1-3 张，拿到最后一张的人输，你来决定谁先拿? 二分查找 每种语言都有 int 型吧？(让我确信他不是前端)，四字节 32 位机器的 -1 的表示是怎么表示的？ ( 在 JS 中，只有 number 类型，使用64位的浮点数表示的， 1.0 和 1 是相等的~) 总结： 面试官是个后端，因为前端面试官正在面试，等待的人有点多，就把我派给了这个面试官~上来问成绩，四六级直接吓尿我，后面连续的逻辑题，第二个俩次机会没有做出来，他就没有给机会了，写了二分查找有一点问题被他指出来了，最后 -1 的表示没说出来，直接爆炸，让我等通知，估计面试官觉得，你这都不会~ 后来想想，这些基础知识还是需要补一下的，这些东西被问倒确实不应该。 郑州玲珑网游加速器 怎么没有写项目经验？(写了啊？) 家庭地址/学校地址 知道我们公司吗？ 为什么想来郑州？ JavaScript 熟悉吗？ =&gt; 还行 CS 熟悉吗？ =&gt; CS？是 CSS 吗？ -&gt; 对，是 CSS 我说还可以，他说那就是一般喽？那问你几个 JS 的问题吧… 值为 false 的？ =&gt; 只说了俩个 ‘’ null undefined +0 / -0 NaN false typeof undefined？ typeof null？ typeof Array？ 如何判别 array？ =&gt; 我怎么感觉她没听清我说的~ arr instanceof Array Array.isArray(arr) toString.call(arr) // [object array] null 和 undefined 的区别？ 浏览器的本地存储？ cookie 和 loaclStorage 的区别？ localStorage 和 sessioStorage 的区别？ 有什么问题？ 睡觉被电话吵醒的~答的比较懵，虽然比较基础，但是是 hr 问的，她估计就是听你能不能说出来，最后通知笔试挂了~ WTF！ 明略数据 自我介绍 平时怎么学习前端的？ 简单介绍一下自己的项目？ 有了解 Angular 吗？ react 呢？ 了解 MVC / MVVM 吗？ Vue 是哪个？ 用到了 jQuery 和 vue，说一下 Vue 和 jQuery 的优缺点吧 了解过 webpack / gulp /grunt / sass / less ？介绍一下吧 =&gt; 说了做过一些简单的压缩文件，热更新的一些东西。用过 stylus 有了解过闭包吗？给几个 P 标签，点击弹出相应的索引(写过几十遍的东西，关键时刻居然掉了链子，怎么也想不起来！) 提到了用ES6 let 解决。 说一说 let 和 var 的区别吧 知道事件委托(事件代理)吗？ 写一下 jQuery 的事件委托 拿起笔试题，说这个你是怎么想的~ 1 == 2 || 1 + 2 / 1 == 2 &amp;&amp; 1 + 2 我当时居然以为我是不是做错了，但是还是按照自己的想法给他说了~(回来测试了一下，没做错！)另外我告诉他另一个题 NaN * 6 我做错了，测试过后发现还是 NaN 另一个笔试题，说说这个 js 和 css 推荐放在什么位置。为什么？ CSS 放在 head 有助于用户体验，提到了首屏加载问题，说了懒加载 面试官惊讶了一下，说你做过懒加载？你给我说说吧 给你出个比较有意思的题吧~ 有 10 只羊，羊每年生一只羊，羊在第 5 年的时候会死掉，写一个函数，输出第 N 年的羊的总数？(先给他说了思路，他说对~然后开始写) 你看到这个题的第一感觉是什么？ 我说是递归~他说那你开始写吧，他想说什么，但是犹豫了下说，那就按照你的思路写吧~回来测试发现当时下标写错了 hr聊人生，为什么学前端，怎么评价自己，有没有女朋友，宣讲会来了是吧？怎么评价我们公司，想不想留北京(一面也问了)，有写博客的习惯？为什么写博客？…有什么想问的~ 总结：最舒服的一次公司笔试题~答的很爽~笔试题感觉掏了很多面试的东西~比如如何看待前端？看过什么书？了解过 webpack / gulp /grunt / sass / less / express/ koa… 想不起来了，总之就是比较火常用的一些东西。第一次和 hr 聊，有点揭自己短，说了自己是二本，说了自己很少团队合作，一般都是一个人学，一个人做项目~ 附上闭包解决方案！12345678910111213141516171819202122232425262728293031323334// 方案一for (var i = 0, len = pDoms.length; i &lt; len; i++) &#123; var tmp = i; pDoms[i].onclick = (function (tmp) &#123; return function () &#123; alert(tmp); &#125; &#125;)(tmp)&#125;// 方案二for (var i = 0, len = pDoms.length; i &lt; len; i++) &#123; pDoms[i].tmp = i; pDoms[i].onclick = function () &#123; alert(this.tmp) &#125;&#125;// 方案三for (var i = pDoms.length - 1; i &gt;= 0; i--) &#123; (function () &#123; var tmp = i; pDoms[i].onclick = function() &#123; alert(tmp) &#125; &#125;)()&#125;// 方案四 ES6 的 letfor (let i = 0, len = pDoms.length; i &lt; len; i++) &#123; pDoms[i].onclick = function (j) &#123; alert(i); &#125;&#125; 123456789101112131415161718// 数羊 =&gt; 其实以前做过类似题，是用递归解决的，但是没太懂，想不起来，只能靠现场发挥了。// 思路：想象成类似于斐波那契数列，每年羊的数都等于前一年羊数的一倍，当从第5年开始，都有5年前的羊死去function countSheep (n) &#123; var arr = [10], i; for (i = 1; i &lt; n; i ++) &#123; // 第一年(下标0)羊为 10， 从第二年开始计算， 即下标从 1 开始 // i &gt; 3 即 第 5 年 if (i &gt; 3) &#123; // 年数大于 5 年时，减去 5 年前的羊，下标减 4 arr[i] = arr[i-1] * 2 - arr[i - 4]; &#125; else &#123; arr[i] = arr[i - 1] * 2; &#125; &#125; // 下标多算了一位，输出第 n - 1 年的羊 return arr[n - 1];&#125;","categories":[{"name":"面试","slug":"面试","permalink":"http:\\\\hexin.life/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http:\\\\hexin.life/tags/面试/"}]},{"title":"web安全","slug":"title-26","date":"2017-09-02T06:49:42.000Z","updated":"2017-09-06T12:02:44.687Z","comments":true,"path":"2017/09/02/title-26/","link":"","permalink":"http:\\\\hexin.life/2017/09/02/title-26/","excerpt":"","text":"代码层面架构层面运维层面安全问题 用户密码被盗取 用户身份被盗用 用户资料被盗取 网站数据库泄露 xss反射型 HTML 标签 alert(document.cookie) HTML 属性 -&gt; &lt;img class=’#{class}&gt; =&gt; script 富文本 浏览器防御并不是所有浏览器都有防御功能浏览器只能防御出现的 script 标签和其他标签，不能防御从 SCRIPT 取值或者富文本类 转义 -&gt; 输入 / 输出 &amp; =&gt; &amp; -&gt; 放在最前面 html 标签 转义 &lt; &gt; =&gt; &lt; &gt; HTML 属性 -&gt; 双引号 -&gt; 单引号 -&gt; 空格 =&gt; 实体 or 安全字符集 转义 “ “ ‘’ =&gt; &quto; &#39; &#32; script 转义 12\\\\ =&gt; \\\\\\\\&quot; =&gt; \\&quot; 4.1. json encodeJSON.stringify(data) 富文本 黑名单 拉黑 / 禁止部分标签和属性 script / a / img / 等等… 123&lt;script&gt; do somesth... &lt;/script&gt; =&gt; html.replace(/&lt;\\s*\\/?script\\s*&gt;/g, &apos;&apos;) &lt;a href=&apos;javascript:alert(1)&apos;&gt; =&gt; html.replace(/javascript:[^&apos;&quot;]*/g, &apos;&apos;)&lt;img src=&apos;123&apos; onerror=&apos;dosth...&apos;&gt; =&gt; html.replace(/onerror\\s*=\\s*[&apos;&quot;]?[^&apos;&quot;]*[&apos;&quot;]?/g, &apos;&apos;) 白名单 保留部分标签和属性 -&gt; 将 html 解析 dom -&gt; 遍历将允许 DOM 之外的标签 / 属性删除 XSS 库 - 第三方库CSP 内容安全策略 -&gt; 用于指定哪些内容可执行不可执行HTTP 头 child-src connect-src default-src font-src frame-src img-src manifest-src media-src object-src script-src style-src worker-src 域名 协议 ‘self’ 和页面同域 ‘unsafe-inline’ 页面内容 ‘unsafe-eval’ eval 函数 ‘none’ 页面任何内容不执行 nonce- hash 相同才会执行 ‘strict-dynamic’ 1ctx.set(`Connect-Security-Policy:`, `default-src &apos;self&apos;`) csrf 跨站请求伪造 Cross Site Request Forgy 利用用户登陆态(cookies) 用户不知情 完成业务请求 盗取资金 冒充发帖评论等… 毁坏网站声誉… 防御 禁止第三方网站的 cookies -&gt; sampsite-strict(添加到cookies) 只有 chrome 和 opera 支持 验证码 / token referer cookies 前端数据储存 后端通过 http 头设置 请求时通过 HTTP 头传给后端 前端可读写 遵守同源策略 12var cookies = document.cookiescookies = &quot;userId=&apos;123&apos;&quot; Domain: localhost Path: / Expires: session =&gt; 只在会话期间有效 Size: 16 http-only: 只能通过 http 来设置 cookies，即 JavaScript 不能设置 cookies secure: 只能在 https 协议中使用 same-site: 是否允许其他第三方网站的请求可以使用 -&gt; 只有 chorme 支持 作用 储存个性化设置 未登录时用户的唯一标识 存储已经登录用户的凭证 用户 Id + 签名 SessionId 储存其他业务数据 安全策略 签名防篡改 -&gt; 不可逆 加密-私有变换 -&gt; 可逆 http-only =&gt; XSS secure =&gt; https 防窃听 same-site =&gt; CSRF 点击劫持 iframe 内嵌 -&gt; opacity: 0 防御 JavaScript 禁止内嵌 123if (top.location != window.location) &#123; top.location = window.location;&#125; 如果禁止了 JavaScript =&gt; X-FRAME-OPTIONS 12345// SAME-ROIGIN 同一个网站// SAMEORIGIN 同一个域// ALLOW-FROM 只能网站内嵌// DENY 不允许内嵌ctx.set(&apos;X-FRAME-OPTIONS&apos;, &apos;DENY&apos;) 传输安全HTTP 插入广告 重定向广告 无法防御 XSS / CSRF HTTPS 证书不被伪造 证书私钥不被泄露 域名管理权不被泄露 CA 坚守原则 用户密码安全 密码的作用 =&gt; 比对，只有用户知道 密码泄露 服务器被入侵 数据库被偷 通讯被偷听 内部人员泄露 撞库 -&gt; 彩虹表 密码的存储 加密 -&gt; 多次变换 md5 =&gt; 雪崩效应 -&gt; 修改一个字符，md5 值完全不同 加盐 密码的传输 https 频率限制 前端加密意义有限 =&gt; 不被拿到明文密码 密码的替代 生物特征密码的问题 指纹 唇纹 人脸 虹膜 声控 … 方便 容易泄露 相似性 - 碰撞 SQL 注入关系型数据库 存放结构化数据 可高效操作大量数据 方便处理数据库之间的关系 常见：access / sqlite / mySql / msSql Server 防御 关闭错误输出 检查数据类型 数据进行转义 参数化查询 ORM 对象关系映射 NoSql 检查数据类型 类型转换 写完整的条件 上传问题 限制上传后缀 文件类型MIME检查 type：image / png … 文件头检查 程序输出 权限互斥 =&gt; 可写与可执行互斥 信息泄露 错误信息失控 SQL 注入 水平权限控=控制不当 -&gt; a 控制 b xss / csrf… OAuth 思想 用户授权 授权行为不泄露敏感信息 授权会过期 不允许批量读取数据 拒绝服务 DOS 攻击 模拟正常用户 大量占用服务器资源 重放攻击 请求被窃听或记录 再次发出请求 =&gt; 多次消费 / 登陆态被盗取 / 多次抽奖 / 投票…","categories":[{"name":"面试","slug":"面试","permalink":"http:\\\\hexin.life/categories/面试/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http:\\\\hexin.life/tags/安全/"}]},{"title":"性能优化","slug":"title-25","date":"2017-09-02T06:49:19.000Z","updated":"2017-09-02T06:50:11.817Z","comments":true,"path":"2017/09/02/title-25/","link":"","permalink":"http:\\\\hexin.life/2017/09/02/title-25/","excerpt":"","text":"减少 HTTP 请求 减少请求资源大小 DNS 缓存 相同资源缓存 CDN 服务端渲染 资源合并与压缩html 压缩 在线网站压缩(x) nodejs提供 构建工具 后端模板引擎渲染 css 压缩 无效代码删除 CS 语义合并 js 压缩和混乱 无效字符删除，删除注释，代码语义的缩减和优化，代码保护 文件合并 开启 gizp问题 首屏渲染 缓存失效 CSS Js 的加载与执行html 渲染 顺序执行，并发加载(并发度) 顺否阻塞 -&gt; css / js 阻塞页面渲染 依赖关系 -&gt; JavaScript 异步加载等 引入方式(css/js) -&gt; link(css) -&gt; defer / async -&gt; 动态异步加载 词法分析 -&gt; 从上到下并发加载 -&gt; 外部资源并发上限 -&gt; 某个域名下并发请求上限 CSS 阻塞 head (link) 引入 会阻塞页面的渲染 css 阻塞 JS 执行(js 可能会依赖(修改) css 样式) css 不阻塞外部脚本加载JavaScript 阻塞 直接引入会阻塞页面渲染 js 不阻塞资源的加载(webkit 预加载) js 顺序执行，阻塞后续 js 逻辑的执行 懒加载和预加载懒加载(src -&gt; 占位符) 图片进入可视区域后请求图片资源(data-original) 对于电商图片很多，页面很长的业务场景 减少无效资源的加载 并发加载资源过多会阻塞 JS 的加载，影响网站使用 判断图片高度进入可视区域 插件预加载 图片等资源在使用之前提前请求 资源使用时能从缓存中加载 页面展示的依赖关系维护(音乐等) img src 设置 display: none; 实现预加载 使用 image 对象 -&gt; 利用 JS 加载时执行 -&gt; 跨域问题 12var image = new Image()image.src = &apos;http://www.somepic.com/somepic&apos; Ajax 12345678910111213141516171819202122var ajax = new XMLHttpRequest()ajax.onreadystatechange = callback;ajax.onprogress = progressCallback;ajax.open(&apos;get&apos;, &apos;http://somepic.com/somepic&apos;, true)ajax.send()function callback () &#123; if(ajax.readyState === 4 &amp;&amp; ajax.status === 200) &#123; var responseText = ajax.responseText; &#125; else &#123; console.log(&apos;Request was unsuccessful: &apos; + ajax.status) &#125;&#125;function progressCallback (e) &#123; e = e || window.event; if (e.lengthCromputable) &#123; console.log(&apos;Recived &apos; + e.loaded + &apos; of &apos; + e.total + &apos; bytes.&apos;) &#125;&#125; 插件 图片优化 图片有损压缩 jpeg / png8 -&gt; png24 -&gt; png32 图片选择合适的种类 CSS 雪碧图 -&gt; 减少 HTTP 请求 -&gt; 单张图片过大，一次加载较慢 image inline 图片的内容以 base64 内嵌 html 中 -&gt; 减少 HTTP 请求数 &lt; 8/4 kb 矢量图 svg =&gt; iconfont 解决 icon 问题 重绘与回流回流 页面盒模型相关的属性 width height padding margin display border border-width border-height 定位及浮动属性 top left rigjt bottom position float clear 改变节点内部文字结构 text-align overflow-y font-weight overflow line-height vertival-align white-space font-size重绘 color border-style border-radius text-decoration background background-image background-position background-repeat background-size outline outline-color outline-style outline-width box-shadow 频繁重回和回流的的 DOM 单独作为一个独立图层，它的重绘和回流影响只有这个图层之中如： gif chrome 创建图层(的条件) 3D 或透视变换 CSS 属性 使用加速视频解码的 &lt;video&gt; 拥有 3D (webGl) 上下文或者加速的 2D 上下文的 &lt;canvas&gt;节点 混合插件 如：flash 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素 拥有加速的 CSS 过滤器的元素 -&gt; tranlate3d 元素包含一个复合层的后代节点 -&gt; 一个元素拥有自己的子元素，子元素在自己的层 元素有一个 z-index 较低 或者包含复合层的兄弟元素 -&gt; 在复合层上渲染 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择 对于动画新建图层 启用 GPU 硬件加速 避免触发或减少重绘 / 回流 将重绘和回流影响范围限制在 单独的图层内 浏览器缓存cookie 因为HTTP请求无状态，所以需要cookie去维持客户端状态 过期时间 expirecookie的生成方式 http response header中的set-cookie js中可以通过document.cookie可以读写cookie 仅仅作为浏览器存储（大小4KB左右，能力被localstorage替代） cookie中在相关域名下面 -&gt; cdn的流量损耗 httponly LocalStorage HTML5设计出来专门用于浏览器存储的 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 浏览器本地缓存方案 SessionStorage 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 对于表单信息的维护 IndexedDBIndexedDB 是一种低级API，用于客户端存储大量结构化数据。该API使用索引来实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。为应用创建离线版本 PWAPWA (Progressive Web Apps) 是一种 Web App 新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，我们从英文缩写来看就能看出来，这是一个渐进式的 Web App，是通过一系列新的 Web 特性，配合优秀的 UI 交互设计，逐步的增强 Web App 的用户体验。 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。快速：针对网页渲染及网络数据访问有较好优化。融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。 Service WorkerService Worker 是一个脚本，浏览器独立于当前网页，将其在后台运行,为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送消息,背景后台同步， geofencing（地理围栏定位），但它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。","categories":[{"name":"面试","slug":"面试","permalink":"http:\\\\hexin.life/categories/面试/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http:\\\\hexin.life/tags/性能优化/"}]},{"title":"2017拼多多前端笔试","slug":"title-22","date":"2017-08-01T13:33:52.000Z","updated":"2017-08-09T17:20:47.856Z","comments":true,"path":"2017/08/01/title-22/","link":"","permalink":"http:\\\\hexin.life/2017/08/01/title-22/","excerpt":"","text":"简答题：settimeout 与 setInterval的区别， 及对他们的内存的分析区别 setTimeout是在一段时间后调用指定函数（仅一次） setInterval是每隔一段时间调用指定函数（N次）1234567function run()&#123; // 其他代码 setTimeout(function()&#123; run(); &#125;, 10000);&#125;run(); 以上面的代码来说, 虽然设置的是10s执行一次, 但是实际时间却是需要// 其他代码的执行时间来确定即setTimeout的间隔时间是, // setTimeout 的间隔时间 === 最小时间是(10s+) 123setInterval(function()&#123; run();&#125;, 10000); 而setInterval, 不会有上面的问题, 但是如果run()的执行时间, 操作大于10s, 那么甚至可能跳过任务; setInterval 和 setTimeout 会产生内存溢出JavaScript setInterval()方法是否导致内存泄漏？ 关于内存泄漏内存程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。（比如 C 语言）必须手动释放内存，程序员负责内存管理。123456char * buffer;buffer = (char*) malloc(42);//...free(buffer) //手动释放内存 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。 垃圾回收机制怎么知道哪些内存不再需要呢？常用的方法是 ‘引用计数’, 语言的引擎有一张 ‘引用表’, 保存了内存里面所有的资源(通常是各种值)的引用次数，当一个值的引用次数为 0 时，表示这个值用不到了，因此可将其释放。 但是如果一个值不再用到了，引用次数却不为 0 ，垃圾回收机制却无法释放这块内存，从而导致内存泄漏。12const arr = [1, 2, 3, 4];console.log(arr); 打印完 arr 之后, arr 便用不到了，引用次数为 1, 但是它还会继续占用内存。123const arr = [1, 2, 3, 4];console.log(arr);arr = null; arr 重置为 null，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0 ，内存就可以释放了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄漏垃圾回收语言的内存泄漏主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。 Mark-and-sweep 大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 不需要的引用是指开发者明知内存引用不再需要，却由于某些原因，它仍被留在激活的 root 树中。在 JavaScript 中，不需要的引用是保留在代码中的变量，它不再需要，却指向一块本该被释放的内存。有些人认为这是开发者的错误。 为了理解 JavaScript 中最常见的内存泄漏，我们需要了解哪种方式的引用容易被遗忘。 常见 JavaScript 内存泄漏意外的全局变量JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。123function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;;&#125; 真相是：123function foo(arg) &#123; window.bar = &quot;this is an explicit global variable&quot;;&#125; 函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。 另一种意外的全局变量可能由 this 创建：123456function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo(); 在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。 全局变量注意事项:尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。 被遗忘的计时器或回调函数在 JavaScript 中使用 setInterval 非常平常。一段常见的代码：12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。 对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。 观察者代码示例：12345var element = document.getElementById(&apos;button&apos;);function onClick(event) &#123; element.innerHTML = &apos;text&apos;;&#125;element.addEventListener(&apos;click&apos;, onClick); // =&gt; 循环调用 对象观察者和循环引用注意事项老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。 脱离 DOM 的引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除.1234567891011121314151617var elements = &#123; button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;)&#125;;function doStuff() &#123; image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑&#125;function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 \\ 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 \\ 以外的其它节点。实际情况并非如此：此 \\ 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 \\ 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 闭包 如果闭包的作用域中保存着一个 HTML 元素，则该元素无法被销毁。(下面代码来自高程) 闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。123456function assgin() &#123; var ele = document.getElementById(&apos;someEle&apos;); ele.onclick = function()&#123; alert(ele.id); &#125;&#125; 以上代码创建了一个作为 ele 元素事件处理程序的闭包，而这个闭包有创建了一个循环的引用，由于匿名函数保存了一个 assgin() 的活动对象的引用 ，因此无法减少对 ele 的引用次数 , 只要匿名函数存在，ele的引用次数至少是 1。我们可以稍微改写一下:12345678function assgin() &#123; var ele = document.getElementById(&apos;someEle&apos;); var id = ele.id ele.onclick = function()&#123; alert(id); &#125; ele = null;&#125; 上面代码中，通过把 ele.id 的一个副本保存在一个变量中，并且在比保重引用该变量消除了循环引用，但是这样还不能解决内存泄露，闭包会引用包含函数的整个活动对象，而其中包含着 ele ，即使闭包不直接引用 ele ，包含函数的活动对象中也会保存 一个引用，因此需要把 ele 变量设置为 null ,这样就解除了对 DOM 对象的引用，减少其引用数，确保能正常回收。 关于内存的发现 chrome 的使用~暂时没有使用过，看不太明白，就不 copy 了。 js闭包测试 =&gt; 看不懂~ 上述内容 copy 自下面二者：JavaScript 内存泄漏教程-阮一峰4类 JavaScript 内存泄漏及如何避免 ajax 原生实现12345678910111213var xhr = createXHR()xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status == 200) &#123; console.log(xhr.responeText) //do sth... &#125; else &#123; console.log(&apos;request fail&apos; + xhr.status) &#125; &#125;&#125;;xhr.open(&apos;get&apos;, &apos;hello.com&apos;, true)xhr.send(null); 闭包的理解闭包是指有权访问另一个函数作用域中的变量的函数。这个口述我还是不知道怎么说，或许是应用不够~看了无数文章到头来敌不过忘记~也可能我理解的还是不到位吧~个人不解释了，放参考链接吧How do JavaScript closures work?–StackOverflow学习Javascript闭包（Closure）–阮一峰的网络日志JS 中的闭包是什么–方应杭JavaScript 中 闭包 的详解闭包–MDN闭包的应用 html中一段文本内容 hdslakddnska8das ，将文本中含有数组[‘d’, ‘a’, ‘‘, ‘8’] 中的内容标记为红色文本(字符串有改动)设定 html 结构12345678910111213 &lt;style&gt; .mark &#123; color: red; &#125; &lt;/style&gt; &lt;html&gt; &lt;body&gt; &lt;div class=&apos;textToMark&apos;&gt; hdslakddnska8das &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法一:循环1234567891011121314151617181920const textToMark = document.querySelector(&apos;.textToMark&apos;);const text = textToMark.innerHTML;const arr = [&apos;d&apos;, &apos;a&apos;, &apos;*&apos;, &apos;8&apos;];const newText = text.split(&apos;&apos;);function toMark (textArr, arr) &#123; for(let i = 0; i &lt; newText.length; i++) &#123; for(let j = 0; j &lt; arr.length; j++) &#123; if(newText[i] == arr[j]) &#123; newText[i] = `&lt;span class=&apos;mark&apos;&gt;$&#123;newText[i]&#125;&lt;/span&gt;`; &#125; &#125; &#125; return newText;&#125;toMark(newText, arr);textToMark.innerHTML = newText.join(&apos;&apos;); 方法二: 字符串的 replace1234567891011const textToMark = document.querySelector(&apos;.textToMark&apos;);const text = textToMark.innerHTML;const reg = /[da\\*8]+/g;var newtext = text.replace(reg, (match) =&gt; &#123; return match = `&lt;span class=&apos;mark&apos;&gt;$&#123;match&#125;&lt;/span&gt;`;&#125;);textToMark.innerHTML = newtext; 代码为个人写出，如果有更好的办法欢迎指教 原生JS创建这样的 dom 结构 &lt; div id=’hello’&gt; &lt; p class=’textToMark’&gt;hdslakddnska8das&lt; p&gt;&lt; /div&gt;123456789101112131415161718function createElement() &#123; var body = document.body; var fragment = document.createDocumentFragment() var div = document.createElement(&apos;div&apos;) div.setAttribute(&apos;id&apos;, &apos;hello&apos;) fragment.appendChild(div) var p = document.createElement(&apos;p&apos;) p.className = &apos;textToMark&apos; p.innerHTML = &apos;hdslakddnska8das&apos; div.appendChild(p); body.appendChild(fragment) &#125; createElement(); 感谢评论指出，已改正，关于节点创建 createElement 的效率问题，如果当插入的节点很多的时候，createElement 的效率会不如 createDocumentFragment .createElement 每次 append 一个节点的时候，都会导致页面的重排，例如: 数据为这样:1234567891011121314&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt; &lt;a href=&quot;www.baidu.com&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;www.helloworld.com&quot;&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;var data = [ &#123; name: &apos;36O秋招&apos;, url: &apos;http://campus.360.cn/2015/grad.html&apos;&#125;, &#123; name: &apos;TX校招&apos;, url: &apos;http://join.qq.com/index.php&apos;&#125;] 1234567891011function appendChildToElement(appendToElement, data) &#123; var a, li; for (var i = 0, len = data.length; i &lt; len; i++) &#123; a = document.createElement(&apos;a&apos;); a.href = data[i].url; a.appChild(document.createTextNode(data[i].name)) li = document.createElement(&apos;li&apos;); li.appendChild(a); appendChildToElement(li); &#125;&#125; 这种情况下，data 内的每一个对象插入到 DOM 结构的时候都会触发一次重排，因此效率会较低。但是我们可以改变他的 display 属性，临时从文档移除 ul ，即可有效减少重排次数。 1234var ul = document.getElementById(&apos;myList&apos;);ur.style.display = &apos;none&apos;;appendChildToElement(ul, data);ul.style.display = &apos;block&apos;; 当然，更好的办法就是利用 createDocumentFragment 来创建一个文档片段.123var fragment = document.createElementFragment();appendChildToElement(fragment, data);document.getElementById(&apos;myList&apos;).appendChild(fragment); 只访问了一次 DOM 节点，只触发了一次重排;再次感谢 @xaclincoln 的指出。 查了一些关于 createDocumentFragment 和 createElement 比较的文章。 createDocumentFragment or createElement–StackOverflow createElement vs createDocumentFragment createElement 与 createDocumentFragment 的点点区别 CreateDocumentFragment 的用处 创建一个函数对 JS 基础类型 ( function, boolean, array, number, string, object) 进行值复制12345678910111213141516function valueToCopy (valueBeCopy) &#123; var copyValue; if (typeof (+valueBeCopy) === &apos;number&apos; &amp;&amp; typeof valueBeCopy !== &apos;object&apos;) &#123; copyValue = +valueBeCopy; &#125; else if (typeof valueBeCopy === &apos;string&apos;) &#123; copyValue = parseInt(copyValue); &#125; else if (typeof valueBeCopy === &apos;object&apos;)&#123; if(Array.isArray(valueBeCopy)) &#123; copyValue = valueBeCopy.slice(); &#125; copyValue = JSON.parse(JSON.stringify(valueBeCopy)) &#125; copyValue = valueBeCopy; // console.log(copyValue) return copyValue; &#125; url 输入到页面完成经历了什么专门整理一篇尽可能详细的~ 选择题执行顺序1234567891011121314var input = document.getElementById(&apos;cls&apos;)input.onmouseup = function() &#123; console.log(&apos;onmouseup&apos;)&#125;input.onmousedown = function() &#123; console.log(&apos;onmousedown&apos;)&#125;input.onclick = function() &#123; console.log(&apos;onclick&apos;)&#125;input.onfocus = function() &#123; console.log(&apos;onfocus&apos;)&#125; onmousedown =&gt; onfocus =&gt; onmouseup =&gt; onclick a 链接默认事件的阻止 A. a.onmouseup = function(e) { e.preventDefault() }B. a.onmousedown = function(e) { e.preventDefault() }C. a.onclick = function(e) { e.preventDefault() }D. A B C 都可以~ =&gt; 经测试只有 onclick 可以 IE浏览器中 attachEvent 方式的事件绑定 attachEvent的this总是Window。123el.attachEvent(&apos;onclick&apos;, function()&#123; alert(this);&#125;); HTTP状态码 400 Bad Request由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。[31] 401 Unauthorized（RFC 7235）参见：HTTP基本认证、HTTP摘要认证类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。 402 Payment Required该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。[34] 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 选择正确答案(构造函数的引用地址)123var str = &apos;asd; var str2 = new String(str) var str1 = new String(str)console.log(str1 == str2 , str1 === str2) A. true trueB. true falseC. false trueD. false false // =&gt; 输出 =&gt; false false 因为 new 出来的俩个字符串引用地址不同 下面的输出结果 (this 指向问题)1234567891011function one () &#123; this.name = 1; return function two () &#123; name = 2; return function three() &#123; var name = 3; console.log(this.name); &#125; &#125;&#125;one()()() // =&gt; 2; 还有一部分题忘掉喽 ~ 还有一些题具体的记不太清了，稍作修改，考点计本差不多，上面答案有的是我自己写的，有的是我 google 整理出来的，笔试期间摄像头坏了，而且不小心弹出去了三四次~就当练习了吧，反正简历也没准备好呢，哦，对了，考点大多都在高程中有详细讲解，需要好好看一下高程，面试应该会问一些 Node 和 ES6吧，如果有错误或者更好的方法请告诉我 更多笔试整理更新在个人博客和Github，欢迎小伙伴来一起准备秋招(求大腿抱)。","categories":[{"name":"2017笔试","slug":"2017笔试","permalink":"http:\\\\hexin.life/categories/2017笔试/"}],"tags":[{"name":"笔试","slug":"笔试","permalink":"http:\\\\hexin.life/tags/笔试/"}]},{"title":"面试准备","slug":"title-21","date":"2017-07-29T08:09:22.000Z","updated":"2017-08-20T15:19:20.867Z","comments":true,"path":"2017/07/29/title-21/","link":"","permalink":"http:\\\\hexin.life/2017/07/29/title-21/","excerpt":"","text":"简答题：settimeout 与 setInterval的区别， 及对他们的内存的分析区别 setTimeout是在一段时间后调用指定函数（仅一次） setInterval是每隔一段时间调用指定函数（N次）1234567function run()&#123; // 其他代码 setTimeout(function()&#123; run(); &#125;, 10000);&#125;run(); 以上面的代码来说, 虽然设置的是10s执行一次, 但是实际时间却是需要// 其他代码的执行时间来确定即setTimeout的间隔时间是, // setTimeout 的间隔时间 === 最小时间是(10s+) 123setInterval(function()&#123; run();&#125;, 10000); 而setInterval, 不会有上面的问题, 但是如果run()的执行时间, 操作大于10s, 那么甚至可能跳过任务; setInterval 和 setTimeout 会产生内存溢出JavaScript setInterval()方法是否导致内存泄漏？ 关于内存泄漏内存程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。（比如 C 语言）必须手动释放内存，程序员负责内存管理。123456char * buffer;buffer = (char*) malloc(42);//...free(buffer) //手动释放内存 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。 垃圾回收机制怎么知道哪些内存不再需要呢？常用的方法是 ‘引用计数’, 语言的引擎有一张 ‘引用表’, 保存了内存里面所有的资源(通常是各种值)的引用次数，当一个值的引用次数为 0 时，表示这个值用不到了，因此可将其释放。 但是如果一个值不再用到了，引用次数却不为 0 ，垃圾回收机制却无法释放这块内存，从而导致内存泄漏。12const arr = [1, 2, 3, 4];console.log(arr); 打印完 arr 之后, arr 便用不到了，引用次数为 1, 但是它还会继续占用内存。123const arr = [1, 2, 3, 4];console.log(arr);arr = null; arr 重置为 null，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0 ，内存就可以释放了。 JavaScript 内存管理JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。 JavaScript 内存泄漏垃圾回收语言的内存泄漏主因是不需要的引用。理解它之前，还需了解垃圾回收语言如何辨别内存的可达与不可达。 Mark-and-sweep 大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。 现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 不需要的引用是指开发者明知内存引用不再需要，却由于某些原因，它仍被留在激活的 root 树中。在 JavaScript 中，不需要的引用是保留在代码中的变量，它不再需要，却指向一块本该被释放的内存。有些人认为这是开发者的错误。 为了理解 JavaScript 中最常见的内存泄漏，我们需要了解哪种方式的引用容易被遗忘。 常见 JavaScript 内存泄漏意外的全局变量JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 window 。123function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;;&#125; 真相是：123function foo(arg) &#123; window.bar = &quot;this is an explicit global variable&quot;;&#125; 函数 foo 内部忘记使用 var ，意外创建了一个全局变量。此例泄漏了一个简单的字符串，无伤大雅，但是有更糟的情况。 另一种意外的全局变量可能由 this 创建：123456function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo(); 在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。 全局变量注意事项:尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。 被遗忘的计时器或回调函数在 JavaScript 中使用 setInterval 非常平常。一段常见的代码：12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 此例说明了什么：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。 对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。 观察者代码示例：12345var element = document.getElementById(&apos;button&apos;);function onClick(event) &#123; element.innerHTML = &apos;text&apos;;&#125;element.addEventListener(&apos;click&apos;, onClick); // =&gt; 循环调用 对象观察者和循环引用注意事项老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。如今，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法，已经可以正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用 removeEventListener 了。 脱离 DOM 的引用有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除.1234567891011121314151617var elements = &#123; button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;)&#125;;function doStuff() &#123; image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑&#125;function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 \\ 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 \\ 以外的其它节点。实际情况并非如此：此 \\ 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 \\ 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 闭包 如果闭包的作用域中保存着一个 HTML 元素，则该元素无法被销毁。(下面代码来自高程) 闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。123456function assgin() &#123; var ele = document.getElementById(&apos;someEle&apos;); ele.onclick = function()&#123; alert(ele.id); &#125;&#125; 以上代码创建了一个作为 ele 元素事件处理程序的闭包，而这个闭包有创建了一个循环的引用，由于匿名函数保存了一个 assgin() 的活动对象的引用 ，因此无法减少对 ele 的引用次数 , 只要匿名函数存在，ele的引用次数至少是 1。我们可以稍微改写一下:12345678function assgin() &#123; var ele = document.getElementById(&apos;someEle&apos;); var id = ele.id ele.onclick = function()&#123; alert(id); &#125; ele = null;&#125; 上面代码中，通过把 ele.id 的一个副本保存在一个变量中，并且在比保重引用该变量消除了循环引用，但是这样还不能解决内存泄露，闭包会引用包含函数的整个活动对象，而其中包含着 ele ，即使闭包不直接引用 ele ，包含函数的活动对象中也会保存 一个引用，因此需要把 ele 变量设置为 null ,这样就解除了对 DOM 对象的引用，减少其引用数，确保能正常回收。 关于内存的发现 chrome 的使用~暂时没有使用过，看不太明白，就不 copy 了。 js闭包测试 =&gt; 看不懂~ 上述内容 copy 自下面二者：JavaScript 内存泄漏教程-阮一峰4类 JavaScript 内存泄漏及如何避免 ajax 原生实现12345678910111213var xhr = createXHR()xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; if(xhr.status == 200) &#123; console.log(xhr.responeText) //do sth... &#125; else &#123; console.log(&apos;request fail&apos; + xhr.status) &#125; &#125;&#125;;xhr.open(&apos;get&apos;, &apos;hello.com&apos;, true)xhr.send(null); 闭包的理解闭包是指有权访问另一个函数作用域中的变量的函数。这个口述我还是不知道怎么说，或许是应用不够~看了无数文章到头来敌不过忘记~也可能我理解的还是不到位吧~个人不解释了，放参考链接吧How do JavaScript closures work?–StackOverflow学习Javascript闭包（Closure）–阮一峰的网络日志JS 中的闭包是什么–方应杭JavaScript 中 闭包 的详解闭包–MDN闭包的应用 html中一段文本内容 hdslakddnska8das ，将文本中含有数组[‘d’, ‘a’, ‘‘, ‘8’] 中的内容标记为红色文本(字符串有改动)设定 html 结构12345678910111213 &lt;style&gt; .mark &#123; color: red; &#125; &lt;/style&gt; &lt;html&gt; &lt;body&gt; &lt;div class=&apos;textToMark&apos;&gt; hdslakddnska8das &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法一:循环1234567891011121314151617181920const textToMark = document.querySelector(&apos;.textToMark&apos;);const text = textToMark.innerHTML;const arr = [&apos;d&apos;, &apos;a&apos;, &apos;*&apos;, &apos;8&apos;];const newText = text.split(&apos;&apos;);function toMark (textArr, arr) &#123; for(let i = 0; i &lt; newText.length; i++) &#123; for(let j = 0; j &lt; arr.length; j++) &#123; if(newText[i] == arr[j]) &#123; newText[i] = `&lt;span class=&apos;mark&apos;&gt;$&#123;newText[i]&#125;&lt;/span&gt;`; &#125; &#125; &#125; return newText;&#125;toMark(newText, arr);textToMark.innerHTML = newText.join(&apos;&apos;); 方法二: 字符串的 replace1234567891011const textToMark = document.querySelector(&apos;.textToMark&apos;);const text = textToMark.innerHTML;const reg = /[da\\*8]+/g;var newtext = text.replace(reg, (match) =&gt; &#123; return match = `&lt;span class=&apos;mark&apos;&gt;$&#123;match&#125;&lt;/span&gt;`;&#125;);textToMark.innerHTML = newtext; 代码为个人写出，如果有更好的办法欢迎指教 原生JS创建这样的 dom 结构 &lt; div id=’hello’&gt; &lt; p class=’textToMark’&gt;hdslakddnska8das&lt; p&gt;&lt; /div&gt;123456789101112131415161718function createElement() &#123; var body = document.body; var fragment = document.createDocumentFragment() var div = document.createElement(&apos;div&apos;) div.setAttribute(&apos;id&apos;, &apos;hello&apos;) fragment.appendChild(div) var p = document.createElement(&apos;p&apos;) p.className = &apos;textToMark&apos; p.innerHTML = &apos;hdslakddnska8das&apos; div.appendChild(p); body.appendChild(fragment) &#125; createElement(); 感谢评论指出，已改正，关于节点创建 createElement 的效率问题，如果当插入的节点很多的时候，createElement 的效率会不如 createDocumentFragment .createElement 每次 append 一个节点的时候，都会导致页面的重排，例如: 数据为这样:1234567891011121314&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt; &lt;a href=&quot;www.baidu.com&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;www.helloworld.com&quot;&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;var data = [ &#123; name: &apos;36O秋招&apos;, url: &apos;http://campus.360.cn/2015/grad.html&apos;&#125;, &#123; name: &apos;TX校招&apos;, url: &apos;http://join.qq.com/index.php&apos;&#125;] 1234567891011function appendChildToElement(appendToElement, data) &#123; var a, li; for (var i = 0, len = data.length; i &lt; len; i++) &#123; a = document.createElement(&apos;a&apos;); a.href = data[i].url; a.appChild(document.createTextNode(data[i].name)) li = document.createElement(&apos;li&apos;); li.appendChild(a); appendChildToElement(li); &#125;&#125; 这种情况下，data 内的每一个对象插入到 DOM 结构的时候都会触发一次重排，因此效率会较低。但是我们可以改变他的 display 属性，临时从文档移除 ul ，即可有效减少重排次数。 1234var ul = document.getElementById(&apos;myList&apos;);ur.style.display = &apos;none&apos;;appendChildToElement(ul, data);ul.style.display = &apos;block&apos;; 当然，更好的办法就是利用 createDocumentFragment 来创建一个文档片段.123var fragment = document.createElementFragment();appendChildToElement(fragment, data);document.getElementById(&apos;myList&apos;).appendChild(fragment); 只访问了一次 DOM 节点，只触发了一次重排;再次感谢 @xaclincoln 的指出。 查了一些关于 createDocumentFragment 和 createElement 比较的文章。 createDocumentFragment or createElement–StackOverflow createElement vs createDocumentFragment createElement 与 createDocumentFragment 的点点区别 CreateDocumentFragment 的用处 创建一个函数对 JS 基础类型 ( function, boolean, array, number, string, object) 进行值复制12345678910111213141516function valueToCopy (valueBeCopy) &#123; var copyValue; if (typeof (+valueBeCopy) === &apos;number&apos; &amp;&amp; typeof valueBeCopy !== &apos;object&apos;) &#123; copyValue = +valueBeCopy; &#125; else if (typeof valueBeCopy === &apos;string&apos;) &#123; copyValue = parseInt(copyValue); &#125; else if (typeof valueBeCopy === &apos;object&apos;)&#123; if(Array.isArray(valueBeCopy)) &#123; copyValue = valueBeCopy.slice(); &#125; copyValue = JSON.parse(JSON.stringify(valueBeCopy)) &#125; copyValue = valueBeCopy; // console.log(copyValue) return copyValue; &#125; url 输入到页面完成经历了什么专门整理一篇尽可能详细的~ 选择题执行顺序1234567891011121314var input = document.getElementById(&apos;cls&apos;)input.onmouseup = function() &#123; console.log(&apos;onmouseup&apos;)&#125;input.onmousedown = function() &#123; console.log(&apos;onmousedown&apos;)&#125;input.onclick = function() &#123; console.log(&apos;onclick&apos;)&#125;input.onfocus = function() &#123; console.log(&apos;onfocus&apos;)&#125; onmousedown =&gt; onfocus =&gt; onmouseup =&gt; onclick a 链接默认事件的阻止 A. a.onmouseup = function(e) { e.preventDefault() }B. a.onmousedown = function(e) { e.preventDefault() }C. a.onclick = function(e) { e.preventDefault() }D. A B C 都可以~ =&gt; 经测试只有 onclick 可以 IE浏览器中 attachEvent 方式的事件绑定 attachEvent的this总是Window。123el.attachEvent(&apos;onclick&apos;, function()&#123; alert(this);&#125;); HTTP状态码 400 Bad Request由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。[31] 401 Unauthorized（RFC 7235）参见：HTTP基本认证、HTTP摘要认证类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。 402 Payment Required该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。[34] 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 选择正确答案(构造函数的引用地址)123var str = &apos;asd; var str2 = new String(str) var str1 = new String(str)console.log(str1 == str2 , str1 === str2) A. true trueB. true falseC. false trueD. false false // =&gt; 输出 =&gt; false false 因为 new 出来的俩个字符串引用地址不同 下面的输出结果 (this 指向问题)1234567891011function one () &#123; this.name = 1; return function two () &#123; name = 2; return function three() &#123; var name = 3; console.log(this.name); &#125; &#125;&#125;one()()() // =&gt; 2; 还有一部分题忘掉喽 ~ 还有一些题具体的记不太清了，稍作修改，考点计本差不多，上面答案有的是我自己写的，有的是我 google 整理出来的，笔试期间摄像头坏了，而且不小心弹出去了三四次~就当练习了吧，反正简历也没准备好呢，哦，对了，考点大多都在高程中有详细讲解，需要好好看一下高程，面试应该会问一些 Node 和 ES6吧，如果有错误或者更好的方法请告诉我 更多笔试整理更新在个人博客和Github，欢迎小伙伴来一起准备秋招(求大腿抱)。 基础知识使用 typeof 能得到哪些基础类型 undefined boolean Number String Object =&gt; null, object, array Function 何时使用 === 何时使用 == 不需要判断类型是否相等，即需要隐式类型转换的时候使用 ==判断对象中属性是否存在 12if(obj.a == nul) // =&gt; 等同于 obj.a === null || obj.a === undefined// =&gt; jquery 推荐写法(源码) 其他情况全部用 === 继承示例示例一:12345678910111213141516171819202122232425262728293031function GetArray(arr) &#123; if(Array.isArray(arr)) &#123; this.arr = arr &#125; else if (typeof arr === &apos;string&apos;)&#123; this.arr = arr.split(&apos;&apos;) &#125; else &#123; this.arr = [arr] &#125;&#125;GetArray.prototype.copy = function(newArr) &#123; return this.arr = newArr.slice()&#125;// 输入 GetArray.prototype.delete = function(num, index, val) &#123; if(val) &#123; return this.arr.splice(findIndex((val)=&gt; &#123; return val === val &#125;), num || 1) &#125; else &#123; return this.arr.splice(index, num || 1) &#125;&#125;var arr1 = [1,2,3,4]var arr2 = []var arr = new GetArray(arr1)arr.copy(arr2)arr.delete(1, 0) 示例二:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Person (name, age) &#123; this.name = name || &apos;just people&apos; this.age = age || &apos;forwver&apos;&#125;Person.prototype.skill = function(val) &#123; console.log(&apos;i can &apos; + val)&#125;function Man (name, age, sex) &#123; this.name = this.name this.age = this.age this.sex = &apos;man&apos;&#125;Person.prototype.love = function(name) &#123; if(name) &#123; console.log(this.name + &apos; love &apos; + name) &#125; else &#123; console.log(this.name + &apos;love self&apos;) &#125;&#125;function Men (name, age, sex) &#123; this.name = name || this.name this.age = age || this.age this.sex = &apos;men&apos;&#125;Man.prototype = new Person()Men.prototype = new Person()function Boy (name, age, sex) &#123; this.name = name this.age = age this.sex = this.sex&#125;Boy.prototype = new Man(&apos;man&apos;)function Girl (name, age, sex) &#123; this.name = name this.age = age this.sex = this.sex&#125;Girl.prototype = new Men(&apos;girl&apos;)var hx = new Boy(&apos;hx&apos;, 22)var xbk = new Girl(&apos;xbk&apos;, 20)var h = new Man(&apos;fh&apos;,0) ##window.onload 和 DOMContentLoaded 的区别 ###window.onload window.onload 需要等到全部的资源加载完成才会触发，不能够编写多个，编写多个时只会执行最后一个,该方法可以绑定到任意元素上 123456789101112&lt;script&gt; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 1) &#125; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 2) &#125; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 3) &#125; //DOM READY 3 &lt;/script&gt; DOMContentLoaded (HTML5) DOMContentLoaded 类似于 jQuery 的$(document).ready(),页面文档（DOM）完全加载并解析完毕之后触发，不会等图片，iframe, css 等资源加载完成。 如果多次使用，会按顺序依次执行相应任务 12345678910111213141516171819202122&lt;body&gt; &lt;script&gt; document.addEventListener(\"DOMContentLoaded\", function (event) &#123; alert(\"DOM ready1\"); &#125;); document.addEventListener(\"DOMContentLoaded\", function (event) &#123; alert(\"DOM ready2\"); &#125;); &lt;/script&gt; &lt;script&gt; document.addEventListener(\"DOMContentLoaded\", function (event) &#123; alert(\"DOM ready3\"); &#125;); document.addEventListener(\"DOMContentLoaded\", function (event) &#123; alert(\"DOM ready4\"); &#125;);// DOM ready1// DOM ready2// DOM ready3// DOM ready4 &lt;/script&gt;&lt;/body&gt; H5之前使用document.onreadystatechange 事件并手动判断document.readyState == ‘complete’ 来代替。 document.readyState / readtstatechange用来表示 DOM 的加载状态，该属性值发生变化时会触发 readtstatechange 事件。有三种取值： loading: DOM 加载中 interactive: DOM 就绪但资源仍在加载中 compelte : DOM 加载完成 由于 IE8 支持 document.readState 属性,因此在 IE8 中常常用来做 DOMContentLoaded 的降级 (fallback) 注意IE8以前的IE不支持document.readyState属性。 可以执行 document.documentElement.doScroll(“left”)， 当DOM未就绪时执行该方法会抛出错误，以此检测DOM是否就绪。 jQuery jQuery也提供了三种方法载入页面事件 $(document).ready(callback)：DOM就绪时执行回调函数，返回值为 docuument 的jQuery集合 $(function() {})：常用写法，返回和参数同上 $(window).load()：当 DOM 完全加载完毕时，页面渲染完成即图片等资源加载完成时触发 .ready() 的实现 12345678910if ( document.readyState === \"complete\" || ( document.readyState !== \"loading\" &amp;&amp; !document.documentElement.doScroll ) ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready window.setTimeout( jQuery.ready );&#125; else &#123; // Use the handy event callback document.addEventListener( \"DOMContentLoaded\", completed ); // A fallback to window.onload, that will always work window.addEventListener( \"load\", completed );&#125; 参考 兼容所有浏览器的 DOM 载入事件 用 JS创建10个 a 标签点击弹出对应序号1234567891011121314151617181920212223(function() &#123; let body = document.body; for (let i = 0; i &lt; 10; i++) &#123; let a = document.createElement('a'); a.textContent = `$&#123;i&#125;`; a.style.cssText = 'margin: 5px;' + 'color: #363636;' + 'font-size: 16px'; body.appendChild(a); &#125; let ac = document.getElementsByTagName('a'); //console.log(ac) for (let i = 0; i &lt; 10; i++) &#123; ac[i].onclick = function() &#123; alert(i) &#125; // ac[i].addEventListener('click', function() &#123; // alert(ac[i].textContent) // &#125;) &#125; &#125;)() 下面代码执行结果1. (预解析)1.1 下面代码执行结果12345678910111213141516171819202122232425console.log( func );var func = 123; console.log( func );function func() &#123; console.log( &apos;Hello js&apos; );&#125;// =&gt; 第一个 console.log(func) =&gt; 打印出下面 func 这个函数体// =&gt; 第二个 console.log(func) =&gt; 打印出刚刚定义的 func 123 //ƒ func() &#123; // console.log( &apos;Hello js&apos; ); //&#125; //123/*********************/console.log( func() );var func = 123;console.log( func );function func() &#123; console.log( &apos;Hello js&apos; );&#125;// =&gt; 第一个则打印函数内部的出 hello js// =&gt; 然后打印出自身的 undefined// =&gt; 第二个 console.log(func) 则打印出 123 1.2 下面代码执行结果1234567891011function func2 () &#123; console.log(&apos;1&apos;, num ); var num = 456; // =&gt; var num 会提前 console.log(&apos;2&apos;, num );&#125;var num = 123;func2(num);console.log(&apos;3&apos;,num)// 1 undefined// 2 456// 3 123 1.3 下面代码执行结果1234567891011function func3 () &#123; console.log(&apos;1&apos;, num ); num = 456; //=&gt; console.log(&apos;2&apos;, num );&#125;var num = 123;func3( num );console.log( &apos;3&apos;,num );// 1 123// 2 456// 3 456 1.4下面代码执行结果123456789101112131415var num = 123;function f1 () &#123; console.log( num ); &#125;function f2 () &#123; var num = 456; f1();&#125;f2();console.log( num );// 123// 123// =&gt; 调用 f2() =&gt; 进入 f2() 内部，var num 被提前解析, f2() 内部执行 num =// 456 =&gt; 进入 f1() =&gt; 这里找不到 num 值, 向全局查询， 发现 num = 123; 打印// =&gt; 最后一个打印全局 num = 123; 1. 下面代码执行结果12345678910111213var length = 10;function fn() &#123; console.log( this.length )&#125;var obj = &#123; length: 5, mathod: function( fn )&#123; fn(); arguments[ 0 ](); &#125;&#125;obj.mathod( fn, 1 );// 10 2 // =&gt; 这里打印出了 10 和 2// =&gt; 10 好理解， 这里难理解的是 2 .// =&gt; 第一个 10 是因为 this 指向了 window， 第二个则是指向了函数内部，打印出来的是函数的长度 如果将函数的 length 改为 len 则很明显了 1234567891011121314var len = 10;function fn() &#123; console.log( this.len )&#125;var obj = &#123; len: 5, mathod: function()&#123; fn(); arguments[ 0 ](); &#125;&#125;obj.mathod( fn , 2);// 10 undefined 我只能理解到这里了，如果有什么错误，希望大神指教。 整理来自： 整理前端面试题(二):预解析及作用域 (含美团面试题) HTTPHTTP response codes HTTP response codes HTTP状态码 你所知道的3xx状态码HTTP 2.0 HTTP2.0性能增强的核心：二进制分帧 HTTP2.0 首部压缩 所有的HTTP2.0的请求都在一个TCP链接上 并行双向字节流的请求和响应 HTTP2.0的请求优先级 HTTP2.0的服务器推送 TAT.bizaiHTTP2.0的奇妙日常TAT.tennylvHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事HTTP2简介和基于HTTP2的Web优化HTTP/2-维基百科 HTTPSHTTPS 与 SSL 证书概要淘宝全站HTTPS实践 ##HTTP协议中的短轮询、长轮询、长连接和短连接 使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control 这篇文章中的 Cache-Control 中的 no-cache 有误，no-cache 不是不可缓存的意思 “no-cache”表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。 相比之下，“no-store”则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。 详情见下方 HTTP 缓存HTTP 缓存HTTP 缓存-MDN 简述如何实现一个模块加载器，实现类似 requirejs 的基本功能JavaScript实现数组的随机排序12345678910111213141516171819// 数组随机排序 var arr = [11, 22, 33, 44, 55, 66, 77, 88, 99, 100]; let len = arr.length; function RandomArray(arr) &#123; if (arr.length == 1) &#123; return arr; &#125; for (let i = 0; i &lt; len; i++) &#123; let random = Math.floor(Math.random() * len); arr.push(arr[random]); arr.splice(random, 1); &#125; console.log(arr); return arr; &#125; RandomArray(arr); 更多实现： 数组元素随机化排序算法实现 数组随机排序 Fisher–Yates shuffle 洗牌算法 实现数组的去重ES512345678910111213141516171819202122232425262728293031323334var arr = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];function duplicatesWithString(arr) &#123; var newArr = []; var tmpArr = []; arr.forEach(function(val) &#123; var key = (typeof val) + val; if(!tmpArr[key]) &#123; //如果为 undefined 就进入循环 tmpArr[key] = true; //设置为 true 表示已经存在该数字 newArr.push(val) &#125; &#125;) return newArr;&#125;duplicatesWithString(arr); // =&gt; [1, &quot;1&quot;, 2, 3, 4, &quot;5&quot;, 5]/******************************///如果想去掉字符串function duplicatesNoString(arr) &#123; var newArr = []; var tmpArr = []; arr.forEach(function(val) &#123; if(typeof val !== &apos;string&apos;) &#123; if(!tmpArr[val]) &#123; //如果为 undefined 就进入循环 tmpArr[val] = true; //设置为 true 表示已经存在该数字 newArr.push(val); &#125; &#125; &#125;) return newArr;&#125;duplicatesNoString(arr) ES6ES6中新增 set 数据结构 set 中不能添加重复元素，如： 123456var mySet = new Set();mySet.add(1); // Set &#123; 1 &#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add(&apos;some text&apos;); // Set &#123; 1, 5, &apos;some text&apos; &#125; 因此我们可利用这个特性 123let arr1 = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];let set = new Set(arr1);console.log(set) // =&gt;&#123;1, &quot;1&quot;, 2, 3, 4,&quot;5&quot;, 5&#125; ES6中Array新增了一个静态方法Array.from，可以把类似数组的对象转换为数组(如通过 QuerySelectAll 得到的 Node List) 123let arr2 = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];let array = Array.from(new Set(arr2));console.log(array) // =&gt;[1, &quot;1&quot;, 2, 3, 4, &quot;5&quot;, 5] 参考六种方法数组去重一行代码实现数组去重（ES6） 实现一个函数，输入 123456789 输出 123，465，78912345678910111213function cal(arr) &#123; var newArr = []; var arr = typeof arr === &apos;string&apos; ? arr : arr.toString(); arr = arr.split(&apos;&apos;); arr.forEach(function(value, index) &#123; if(index % 3 === 0 &amp;&amp; index != 0) &#123; newArr.push(&apos;,&apos;) &#125; newArr.push(arr[index]); &#125;) return newArr.join(&apos;&apos;); &#125;// 判断为三则push进新的数组 JavaScript 中 apply 、call、bindJavaScript 中 apply 、call 的详解js的call() ，apply() 两种方法的区别和用法，最白话文的解释，让枯燥滚粗！ JS 实现不用第三个变量交换俩个变量我自己想的是前段时间学习 ES6 时遇到的； [a, b] = [b, a] 然后网上搜了一下，发现有人整理的很全，就拉过来学习吧 七种方案解决JavaScript交换两个变量值的问题 实现对对象和数组的 forEach1234567891011121314151617181920212223242526272829303132333435363738394041function forEach(obj, index, value, fn) &#123; if (obj == null) return; if (!fn) &#123; if (typeof obj === &apos;function&apos; &amp;&amp; obj.call) &#123; fn = Function &#125; else if (typeof obj.forEach === &apos;function&apos; &amp;&amp; obj.forEach != arguments.callee) &#123; // 如果对象内部已经实现 forEach ，例如数组 obj.forEach(index, value) return; &#125; else if (typeof obj.length == &apos;number&apos;) &#123; // 如果是数组或者类数组的对象 _Array_forEach(obj, index, value) return; &#125; &#125; _Function_forEach(fn || Object, obj, index, value)&#125;function _Array_forEach(arr, index, value) &#123; if(arr == null) return ; let i = 0, len = arr.length; if(typeof arr === &apos;string&apos;) &#123; for(; i &lt; len; i++) &#123; index.call(value, arr.charAt(i), i, arr) &#125; &#125; else &#123; for(; i &lt; len; i++) &#123; index.call(value, arr[i], i, arr) &#125; &#125;&#125;function _Function_forEach (fn, obj, index, value) &#123; for(let key in obj) &#123; if(obj.hasOwnProperty(key)) index.call(value, obj[key], key, obj) &#125;&#125; 采自 大神司徒正美javascript 的forEach函数 实现对时间 xxxx-xx-xx 的获取1234567891011121314151617181920function formatDate(date) &#123; if (!date) &#123; date = new Date() &#125; const year = date.getFullYear(), month = (date.getMonth() + 1), // month 是从 0 开始 day = date.getDate(), hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds(); return year + &apos;-&apos; + month + &apos;-&apos; + day&#125;var date = new Date()var formatDate = formatDate(date)console.log(formatDate)2017-8-8 HTML 知识用 div 实现 textarea Textarea 对象代表 HTML 表单中的一个文本域 (text-area)。 首先我们需要可输入功能 HTML5 新增 contenteditable 属性他有 true 和 flase 俩个值，true 指定元素是可编辑的 123&lt;div contenteditable=&apos;true&apos;， class=&apos;div-text&apos;&gt; hello&lt;/div&gt; 此时效果已经有了，点击是自带聚焦发光还挺好看的，但是只有点击上的时候才会显示可输入框，我们加一个 border 模拟一下即可。12345678910.div-text&#123; min-height: 20px; min-width: 80px;&#125;.div-text&#123; padding-left: 3px; width: 100px; border: 1px solid #ccc;&#125; 然后是自定义拖动大小, 利用 CSS3 的 resize ，再增加 overflow 属性123456margin: 50px;padding-left: 3px;width: 100px;border: 1px solid #ccc;resize: both;overflow: hidden; 不喜欢 textarea 右下角图标时，也可以利用这个属性去除右下角的拖动图标 1resize: none; canvas、svg的区别 由于我没做过 svg ，canvas 也只是联系国一个时钟而已，就在这里搜了一些资料。 SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？ Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的-w3school 有了css3之后，我们还需要canvas还有svg吗？ Canvas 与 SVG的主要区别 #13-github SVG初体验 可访问性如何提高网站的可访问性（Accessibility）？——来自W3C的指南10步大幅提升网站可访问性CSS 知识链接的伪类顺序（:link :visited :hover :active）CSS中超链接伪类link,visited,hover,active的顺序分析 CSS中link 和@import的区别是 差别1：老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。 link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 差别2：加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显（梦之都加载CSS的方式就是使用@import，我一边下载一边浏览梦之都网页时，就会出现上述问题）。 差别3：兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。 差别4：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。 大致就这几种差别了（如果还有什么差别，大家告诉我，我再补充上去），其它的都一样，从上面的分析来看，还是使用link标签比较好。 差别5：@import可以在css中再次引入其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表，如： 123456789101112main.css———————-@import “sub1.css”;@import “sub2.css”;sub1.css———————-p &#123;color:red&#125;;sub2.css———————-.myclass &#123;color:blue&#125; 这样更利于修改和扩展(但是这样做有一个缺点，会对网站服务器产生过多的HTTP请求，以前是一个文件，而现在却是两个或更多文件了，服务器的压力增大，浏览量大的网站还是谨慎使用。有兴趣的可以观察一下像新浪等网站的首页或栏目首页代码，他们总会把css或js直接写在html里，而不用外部文件) 详解CSS外部引用之link与@import的区别-大前端外部引用CSS中 link与@import的区别 v CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？CSS3新增了哪些特性？CSS 选择符： id 选择器(#id): HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 class 选择器(.class): class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点”.”号显示： 标签选择器(div / p /span): 在 css 中直接使用 html 的标签进行选择 相邻选择器(div1,div2,div3): 选择所有 div1，div2，div3 元素 子选择器(div&gt;p): 选择父元素为 div 元素的所有 p 元素 后代选择器(div p): 选择 div 元素内部的所有 p 元素。 通配符选择器( * ): 选择所有元素。 属性选择器([target]): 选择所有属性为 target 的元素。 [target=_blank]: 选择 target=”_blank” 的所有元素。 [title~=flower]: 选择 title 属性包含单词 “flower” 的所有元素。 [lang|=en]: 选择 lang 属性值以 “en” 开头的所有元素。 :link (a:link) 选择所有未被访问的链接。 1 选择器 例子 例子描述 CSS :visited (a:visited) 选择所有已被访问的链接。 1 :active (a:active) 选择活动链接。 1 :hover (a:hover) 选择鼠标指针位于其上的链接。 1 :focus (input:focus) 选择获得焦点的 input 元素。 2 :first-letter (p:first-letter) 选择每个 p 元素的首字母。 1 :first-line (p:first-line) 选择每个 p 元素的首行。 1 :first-child (p:first-child) 选择属于父元素的第一个子元素的每个 p 元素。 2 :before (p:before) 在每个 p 元素的内容之前插入内容。 2 :after (p:after) 在每个 p 元素的内容之后插入内容。 2 等等等等….查看手册吧~太多了，记住常用的就行了，其他的用到了再查吧。 CSS 伪类(觉得这个挺重要的-列举的有点多) :first-of-type (p:first-of-type) 选择属于其父元素的首个 p 元素的每个 p 元素。 3 :last-of-type (p:last-of-type) 选择属于其父元素的最后 p 元素的每个 p 元素。 3 :only-of-type (p:only-of-type) 选择属于其父元素唯一的 p 元素的每个 p 元素。 3 :only-child (p:only-child) 选择属于其父元素的唯一子元素的每个 p 元素。 3 :nth-child(n) (p:nth-child(2)) 选择属于其父元素的第二个子元素的每个 p 元素。 3 :nth-last-child(n) (p:nth-last-child(2)) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) (p:nth-of-type(2)) 选择属于其父元素第二个 p 元素的每个 p 元素。 3 :nth-last-of-type(n) (p:nth-last-of-type(2)) 同上，但是从最后一个子元素开始计数。 3 :last-child (p:last-child) 选择属于其父元素最后一个子元素每个 p 元素。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 p 元素。 3 :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 :root :root 选择文档的根元素。 3 :empty ( p:empty ) 选择没有子元素的每个 p 元素（包括文本节点）。 3 :target ( #news:target ) 选择当前活动的 #news 元素。 3 :enabled ( input:enabled ) 选择每个启用的 input 元素。 3 :disabled ( input:disabled ) 选择每个禁用的 input 元素 3 :checked ( input:checked ) 选择每个被选中的 input 元素。 3 :not(selector) ( :not(p) ) 选择非 p 元素的每个元素。 3 ::selection ( ::selection ) 选择被用户选取的元素部分。 3 部分应用:after伪类 经典的清除浮动 =&gt; :after伪类+content 清除浮动的影响 123456789.fix:after&#123; display:block; content:&quot;clear&quot;; height:0; clear:both; overflow:hidden; visibility:hidden;&#125;.fix&#123;*zoom:1;&#125; /* IE */ :after伪类+content 让大小不固定图片垂直居中 12345678910111213141516171819.pic_box&#123; width:300px; height:300px; background-color:#beceeb; font-size:0; *font-size:200px; text-align:center; &#125;.pic_box img&#123; vertical-align:middle;&#125;.pic_box:after&#123; display:inline-block; width:0; height:100%; content:&quot;center&quot;; vertical-align:middle; overflow:hidden;&#125; ::selection 伪元素(css3 唯一新增伪元素) 浏览器自带选取后的背景是蓝色，我们可以利用这个将选取背景设定称自己喜欢的样子1&lt;p&gt;dsadkladja&lt;/p&gt; 123p::selection&#123; background-color: red;&#125; 效果： CSS 选择器参考手册-w3school 到这里已经分不清什么是伪类什么是伪元素了伪类: 用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素： 用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。虽然CSS3标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法。为了向后兼容，我们建议你在目前还是使用单冒号的写法。 伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。总结伪类与伪元素-腾讯 AlloyTeamCSS伪类与CSS伪元素的区别及由来CSS3伪类与伪元素的区别及注意事项 CSS 可继承属性 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 个人不太喜欢记这些，记一下常用的吧~其他的慢慢经验积累吧，一样铺链接 Which CSS properties are inherited?Appendix F. Full property table-其中列出了是否可以继承 CSS3 权重 !important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承 选择器权重值的计算 A B C D 内联 =&gt; id =&gt; 伪类 =&gt; 伪元素及标签 0 =&gt; 0 =&gt; 0 =&gt; 0 A：如果规则是写在标签的style属性中（内联样式），则A=1，否则，A=0. 对于内联样式，由于没有选择器，所以 B、C、D 的值都为 0，即 A=1, B=0, C=0, D=0（简写为 1,0,0,0，下同）。 B：计算该选择器中ID的数量。（例如，#header 这样的选择器，计算为 0, 1, 0, 0）。 C：计算该选择器中伪类及其它属性的数量（包括类选择器、属性选择器等，不包括伪元素）。 （例如， .logo[id=’site-logo’] 这样的选择器，计算为 0, 0, 2, 0）。 D：计算该选择器中伪元素及标签的数量。（例如，p:first-letter 这样的选择器，计算为0, 0, 0, 2）。 计算权重值时，A, B, C, D 四组值，从左到右，分组比较，如果 A 相同，比较 B, 如果 B 相同，比较 C, 如果 C 相同，比较 D, 如果 D 相同，后定义的优先。 关于 inherit 来的属性 继承而来的属性值，权重永远低于明确指定到元素的定义。只有当一个元素的某个属性没有被直接指定时，才会继承父级元素的值 特殊的 !important 有 !important 指定的权重值大于所有未用 !important 指定的规则。包括内联 不过我记得 chrome 浏览器自带的 input框聚焦时的黄色 好像是 !important 都不能覆盖的如果多条规则中都对同一个属性指定了 !important 呢？这时候 !important 的作用相互抵销，依然按照ABCD四组计算比较。如何和何时使用CSS的!important 深入解析CSS样式层叠权重值 CSS选择器距离无关 CSS 清除浮动clearfix改良及overflow:hidden详解【译文】那些年我们一起清除过的浮动CSS之BFC详解CSS float浮动的深入研究、详解及拓展(一)css-float浮动的深入研究、详解及拓展二CSS3新增特性 CSS3 边框 border-radius box-shadow border-image =&gt; border-image: source slice width outset repeat; =&gt; border-image: url(border.png) 30 round ( 设置图像边界是否应重复（repeated）、拉伸（stretched）或铺满（rounded）); CSS3 圆角 =&gt; border-radius CSS3 背景 background-image background-size background-origin =&gt; background-origin:content-box ( border-box ); background-clip CSS3 渐变 =&gt; 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 background: linear-gradient(to bottom right, red , blue); / 标准的语法 / CSS3 文本效果 text-shadow box-shadow text-overflow CSS3文本溢出属性指定应向用户如何显示溢出内容 word-wrap 自动换行属性允许您强制文本换行 - 即使这意味着分裂它中间的一个字 word-break 单词拆分换行 CSS3 字体 =&gt; CSS3 @font-face 规则 CSS3 2D 转换 translate() translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。 rotate() rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转 scale() scale()方法，该元素增加或缩少的大小，取决于宽度（X轴）和高度（Y轴）的参数： skew() 包含两个参数值skewX(&lt; angle&gt;), skewY(&lt; angle&gt;)，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜 matrix() matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 CSS3 3D 转换 perspective(n) =&gt; 定义 3D 转换元素的透视视图。 CSS3 过渡 transition =&gt; 简写属性，用于在一个属性中设置四个过渡属性。 =&gt; 3 transition-property =&gt; 规定应用过渡的 CSS 属性的名称。 =&gt; 3 transition-duration =&gt; 定义过渡效果花费的时间。默认是 0。 =&gt; 3 transition-timing-function =&gt; 规定过渡效果的时间曲线。默认是 “ease”。 =&gt; 3 transition-delay =&gt; 规定过渡效果何时开始。默认是 0。 =&gt; 3 CSS3 动画 =&gt; CSS3 @keyframes 规则 CSS3 多列 CSS3 用户界面 resize =&gt; 属性指定一个元素是否应该由用户去调整大小 box-sizing =&gt; box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。 outline-offset =&gt; outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间 轮廓可能是非矩形border、outline、boxshadow那些事以及如何做内凹圆CSS3如何实现圆角的outline效果？ CSS3 图片- [响应式图片](http://www.runoob.com/try/try.php?filename=trycss_ex_images_responsive) =&gt; max-width: 100%; - 图片滤镜 =&gt; [css滤镜](http://www.runoob.com/cssref/css3-pr-filter.html) - [响应式图片相册](http://www.runoob.com/try/try.php?filename=trycss_image_gallery_responsive) - [图片 Modal(模态)](http://www.runoob.com/try/try.php?filename=trycss_image_modal_js) CSS3 按钮 按钮动画 CSS3 分页 CSS3 框大小 =&gt; box-sizing 属性可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。- 关于 [border-box ](http://hexin.life/2017/07/11/title-15/) CSS3 弹性盒子 CSS3 多媒体查询- viewport(视窗) 的宽度与高度 - 设备的宽度与高度 - 朝向 (智能手机横屏，竖屏) 。 - 分辨率 垂直居中大小不固定的图片、多行文字的水平垂直居中七种方法实现俩侧定宽中间自适应 浮动 绝对定位 表格 flex grid 圣杯 双飞翼俩侧定宽中间自适应 更多 CSS布局中圣杯布局与双飞翼布局的实现思路差异在哪里？双飞翼布局介绍-始于淘宝UED关于「圣杯布局」 关于 flex 用法 Flex 布局语法教程Flex 布局教程：语法篇–阮一峰Flex 布局教程：实例篇 CSS HTML 写作习惯/规范-网易NEC规范Node 功能类实现联动放大镜面试题整理 前端面试题及答案汇总 前端开发面试题集锦 2017年前端面试题最新汇总 30个你 “ 不可能全部会做 ” 的javascript题目及答案 百度糯米前端技术学院 newcode 牛客网 lint-code 百度 FEX 的面试过程 Node interview of 饿了么 Front-end-Developer-Interview-Questions 一些个面试题与js知识点 面试题 知识整理及总结多来于网络及他人博客，由于时间原因，不能每一个知识点都完整的整理出来，因此附带了参考/学习链接。也等于一个知识点的梳理。","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"面试准备","slug":"面试准备","permalink":"http:\\\\hexin.life/tags/面试准备/"}]},{"title":"HTTP 表单编码 enctype(转)","slug":"title-18","date":"2017-07-26T16:12:42.000Z","updated":"2017-08-07T11:49:24.684Z","comments":true,"path":"2017/07/27/title-18/","link":"","permalink":"http:\\\\hexin.life/2017/07/27/title-18/","excerpt":"","text":"在web开发中最常见的莫过于GET和POST，其中 GET 一般将参数编码在 url 中（HTTP header）来传递数据； 而POST或PUT数据必须放在消息主体（entity-body）中，这样的数据便是HTTP表单，表单数据的编码方式应在 HTTP 头中进行设置（Content-Type header字段），常见的编码方式有（HTTP采用MIME框架，编码方式可以是任何MIME类型）： URLencoded: application/x-www-form-urlencoded Multipart: multipart/form-data JSON: application/json XML: text/xml 纯文本: text/plain 在Web开发中，前三种格式非常常见。HTML中 &lt; form &gt; 支持 urlencoded,multipart,plain text，通过 enctype 属性来进行设置。AJAX 中默认的则是 JSON 编码格式。 URLencodedHTML中 &lt; form &gt; 标签的enctype属性用来指定表单编码格式，默认为 application/x-www-form-urlencoded，即以下两个表单完全等价。123456&lt;form method='post'&gt; &lt;input type=\"text\" name='title'&gt; &lt;input type=\"text\" name='subtitle'&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 123456&lt;form method='post' enctype='application/x-www-form-urlencoded'&gt; &lt;input type=\"text\" name='title'&gt; &lt;input type=\"text\" name='subtitle'&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 上述表单将会显示为两个文本框和一个提交按钮。我们在文本框中分别写入 test 和中国后，点击提交按钮。产生的 HTTP 请求可能是这样的： 可以打开 Chrome 控制台的 Network 标签，找到这次请求，便可以看到下面的信息。 请求头（这里只给出了Content-Type 字段）：12POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded 请求体： 1title=test&amp;subtitle=%E4%B8%AD%E5%9B%BD 这里你看到的%E4%B8%AD%E5%9B%BD即是中国按照base64编码（url通用的编码方式）后的结果。可以在Chrome Console中通过decodeURI(‘%E4%B8%AD%E5%9B%BD’)来解码。 Multipartmultipart 编码方式则需要设置 enctype 为 multipart/form-data。 12345&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"title\" value=\"harttle\"&gt; &lt;input type=\"file\" name=\"avatar\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 这里我们还设置了&lt; input type=’text’ &gt;的默认值为 harttle。该表单将会显示为一个文本框、一个文件按钮、一个提交按钮。然后我们选择一个文件：chrome.png，点击表单提交后产生的请求可能是这样的： 请求头：12POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 请求体：12345678910------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;title&quot;harttle------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;chrome.png&quot;Content-Type: image/png ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这便是一个multipart编码的表单。Content-Type中还包含了boundary的定义，它用来分隔请求体中的每个字段。正是这一机制，使得请求体中可以包含二进制文件（当然文件中不能包含boundary）。 除了application/x-www-form-urlencoded和multipart/form-data，HTML的&lt; form &gt;还支持text/plain。此外，如果想提交其他编码类型的表单，必须通过AJAX技术，接下来我们介绍一个常用的JSON数据的提交。 JSON从JavaScript中提交 JSON 数据真是再方便不过了，jquery、angularJS 等框架都封装了更好用的 AJAX 方法。例如：1234$.post(&apos;/xxx&apos;, &#123; title: &apos;test&apos;, content: [1,2,3] &#125;); 该JavaScript执行后可能生成如下的 HTTP 请求： 请求头：12POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8 请求体：1&#123;&quot;title&quot;:&quot;test&quot;,&quot;content&quot;:[1,2,3]&#125; XML请求头：12POST http://www.example.com HTTP/1.1Content-Type: text/xml 请求体：12345678&lt;!--?xml version=&quot;1.0&quot;?--&gt;&lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt;&lt;/methodcall&gt; 转载来自： http://harttle.com/2016/04/11/http-form-encoding.html","categories":[{"name":"转载","slug":"转载","permalink":"http:\\\\hexin.life/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http:\\\\hexin.life/tags/转载/"}]},{"title":"正则表达式学习","slug":"title-17","date":"2017-07-16T16:12:42.000Z","updated":"2017-07-30T15:59:40.496Z","comments":true,"path":"2017/07/17/title-17/","link":"","permalink":"http:\\\\hexin.life/2017/07/17/title-17/","excerpt":"","text":"为了方便查询和学习，这里对正则表达式做一个整理这里推荐一个正则练习的网站 , 将晦涩的正则表达式用图形描述出来 RegExper https://regexper.com/ 像这个样子(邮箱验证)： 关于正则表达式 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 假设你在一篇英文小说里查找 hi，你可以使用正则表达式hi。这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配 hi, HI, Hi, hI 这四种情况中的任意一种。不幸的是，很多单词里包含hi这两个连续的字符，比如 him hi history high 等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用 \\bhi\\b 。 使用正则表达式 : 12var reg = /\\w+\\s/g; var reg = new RegExp(\"\\\\w+\\\\s\", \"g\"); 元字符 . 只能匹配一个字节的字符，不能识别换行符,回车符，行分隔符，段分隔符等换行符,回车符，行分隔符，段分隔符 需要用 s 修饰符来识别， s 修饰符目前处于提案状态 反义字符 转义字符 重复匹配 分组 / 捕获 下面的脚本使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的 $1 , $2 表示第一个和第二个括号的子字符串匹配。 var re = /(\\w+)\\s(\\w+)/;var str = “John Smith”;var newstr = str.replace(re, “$2, $1”);console.log(newstr); 这个表达式输出 “Smith John”。 贪婪 / 惰性 修饰符 ES6 新增修饰符y 修饰符1234567891011let str = 'bb_b=b+bbb++bb';let reg1 = /b+/g; let reg2 = /b+/y; let exec1 = reg1.exec(str);let exec2 = reg2.exec(str);console.log('OneExec:\\n' + 'exec1: ' + exec1 + '\\texec1: ' + exec2) //bb bbconsole.log('TwoExec:\\n' + 'exec1: ' + reg1.exec(str) + '\\texec1: ' + reg2.exec(str)) // b null //g 第二次自动匹配下一个位置,而 y 不是console.log(reg1.sticky, reg2.sticky) // 检测是否开启了 y u 修饰符 (unicode)123456789101112131415161718192021222324 var str = '\\uD83D\\uDC2A'; var reg1 = /^\\uD83D/;var reg2 = /^\\uD83D/u;console.log('u1: ' + reg1.test(str)) //true //当作俩个字节处理console.log('u2: ' + reg2.test(str)) //false // 当作了一个字节处理console.log(/\\u&#123;61&#125;/.test('a')); // false 这里不识别 \\u&#123;61&#125; 中的 &#123;61&#125;-&gt; unicode编码 // a 的 unicode编码是 61console.log(/\\u&#123;61&#125;/u.test('a')); //trueconsole.log('\\u&#123;54564&#125;'); //񔕤console.log('\\u&#123;2048&#125;'); //⁈let z1 = '񔕤';let z2 = '⁈';let reg3 = /^.$/;let reg4 = /^.$/u;let test3 = reg3.test(z1);let test4 = reg3.test(z2); // . 只能匹配一个字节的字符，也不能识别换行符等let test5 = reg4.test(z1); //大于俩个字节时，使用 u 修饰符console.log('z1: ' + test3 + ' z2: ' + test4 + ' z1(u): ' + test5); // z1: false z2: true z1(u): true ES6 新增12345678910111213 let reg1 = new RegExp('xyz', 'i'); // round1let reg2 = new RegExp(/xyz/g); // round2 ES5 只能输入一个参数let test1 = reg1.test('xyz123'); //truelet test2 = reg2.test('xyz123'); //true// --&gt; flag es6 新添加，用来获取正则的修饰符 console.log(test1, test2, reg1.flags, reg2.flags)let reg3 = new RegExp(/xyz/g, 'i'); // ES6 允许这种情况输入俩个参数let flag3 = reg3.flags; console.log(flag3); // -&gt; i 这里 i 覆盖了前面的g 使用正则表达式正则表达式属性 lastindex 只在全局匹配时有效例： var myRe = new RegExp(“d(b+)d”, “g”);var myArray = myRe.exec(“cdbbdbsbz”); 通过这些脚本，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。正则表达式执行返回信息 对象 ———— 属性或索引描述 ————– 在例子中对应的值 myArray 匹配到的字符串和所有被记住的子字符串。 [“dbbd”, “bb”] index 在输入的字符串中匹配到的以0开始的索引值。 1 input 初始字符串。 “cdbbdbsbz” [0] 匹配到的所有字符串（并不是匹配后记住的字符串）。注：原文”The last matched characters.”，应该是原版错误。匹配到的最后一个字符索引。 “dbbd” myRe lastIndex 下一个匹配的索引值。（这个属性只有在使用g参数时可用在 通过参数进行高级搜索 一节有详细的描述.) 5 source 模式文本。在正则表达式创建时更新，不执行。 “d(b+)d” 正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search和 split 方法。 方法及描述 : exec &nbsp;&nbsp;一个在 正则 RegExp 中执行查找匹配的 字符串 String 方法，它返回一个数组（未匹配到则返回null）。例： match&nbsp;&nbsp;一个在 字符串 中执行查找匹配的 String 方法，它返回一个数组或者在未匹配到时返回null。例： search&nbsp;&nbsp;一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 test&nbsp;&nbsp;一个在字符串中测试是否匹配的RegExp方法，它返回true或false。例：这里根据测试次数不同， lastindex 值改变，结果会有所不同例： replace&nbsp;&nbsp;一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。例：其中 function 方法： split&nbsp;&nbsp;一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。例： 常见的正则表达式 邮箱： 1/\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*/ URL 地址： 1/^https?:\\/\\/(([a-zA-Z0-9_-])+(\\.)?)*(:\\d+)?(\\/((\\.)?(\\?)?=?&amp;?[a-zA-Z0-9_-](\\?)?)*)*$/i 手机号码： 1/^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/ 匹配身份证号： 1/^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$/ 邮政编码： 1/^[1-9]\\d&#123;5&#125;(?!\\d)$/ 匹配日期(yyyy-mm-dd)： 1/^[1-2][0-9][0-9][0-9]-[0-1]&#123;0,1&#125;[0-9]-[0-3]&#123;0,1&#125;[0-9]$/ 匹配 HTML 标签： 1/&lt;(\\S*?) [^*&gt;.*?&lt;/\\1&gt;|&lt;.*?/&gt;/gm 匹配中文字符： 1/[\\u4e00-\\u9fa5]/gm 只能输入数字： 1/^\\d+$/ 只能由英文字母/数字/下划线组成： 1/^\\w+$/ 只能英文和数字组成： 1/^[a-z0-9]+$/i 正则表达式学习正则表达式快速参考-MSDN正则表达式-MDN正则表达式30分钟入门教程菜鸟教程-正则表达式","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http:\\\\hexin.life/tags/正则表达式/"}]},{"title":"url 从输入到页面渲染完成到底发生了什么","slug":"title-24","date":"2017-07-11T13:32:07.000Z","updated":"2017-08-09T17:35:54.173Z","comments":true,"path":"2017/07/11/title-24/","link":"","permalink":"http:\\\\hexin.life/2017/07/11/title-24/","excerpt":"","text":"开始上网，输入 url当我们开始输入 url 的时候，浏览器就已经开始匹配 url ，从历史纪录，书签等，找到已经输入的字符串可能对应的 url ，然后给出智能提示，自动补全等。 解析URL 浏览器通过 URL 能够知道下面的信息： Protocol “http”使用HTTP协议 Resource “/“请求的资源是主页(index)输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。转换非 ASCII 的 Unicode 字符 浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符 这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码检查 HSTS 列表 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站 如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送 注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。浏览器查找 url 的 Ip 地址 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。 首先查看本地硬盘的 host 文件，查看其中有没有和这个域名对应的规则，如果找到，就直接使用 host 中的 ip 地址。 如果 host 中没能找到对应的 ip 地址，浏览器会发出一个 DNS 请求到本地 DNS 服务器，即网络接入提供商(中国移动，中国电信等) 本地 DNS 服务器查询它的缓存记录，如果有就直接返回查询结果，此过程是递归查询，如果没有则会向 DNS 根服务器查询 跟服务器没有相应的记录时，就告诉本地 DNS 服务器可以去域名服务器查询，并告知域名服务器的 IP， 本地服务器向域名服务器发出请求，在下图中请求的对象是 .com 服务器， .com 服务器收到请求后，也不会直接返回对应关系，而是告诉本地 DNS 服务器，你所查询的域名的服务器的地址。 本地服务器向查询的域名服务器发出请求，此时能收到相应的域名和 IP 的地址，本地 DNS 不仅要把返回的 IP 和域名返回给用户还要把这个关系保存到缓存中，以防下次用户请求时，可以快速返回结果，加快了网络的访问。 关于 DNS 浏览器向 Web 服务器发出 HTTP 请求拿到域名对应的 IP 地址之后，浏览器会以随机一个( 1024 &lt; 端口号 &lt; 65535 ) 向 Web 服务器 ( nginx ) 的 80 端口号发出 TCP 的连接请求，经过各种路由设备(局域网除外)，到达网卡，进入到内核的 TCP/IP 协议栈( 识别连接请求，解封包等 )，最终到达 Web 应用程序，建立起了 TCP/IP 连接。 建立起 TCP 连接之后，发起一个 HTTP 请求 ( 一般常用是 get post )。一般一个 HTTP 请求包含： 请求的 url 协议/版本 请求头 request header 请求体 request body 最后一个请求头后面是空行，发送回车符和换行符，通知服务器以下不再是请求头 TCP 三次握手与四次挥手 TCP协议中的三次握手和四次挥手(图解) 服务器的永久重定向响应服务器给浏览器响应一个 301 的永久重定向，这样浏览器访问 http://www.google.com 而不是 http://google.com ，这是由于搜索引擎排名的原因，比如我的网站为了输入方便，在进行 DNS 解析时，将 http://www.hexin.life 和 http://hexin.life 定位到了同一网站下，搜素引擎会认为他们是俩个网站，从而造成搜索排名下降。而当 301 重定向之后，搜素引擎便会把含 www 的和不含的放在同一个网站排名中，而且使用 www 和非 www 时，也会缓存多次，所以会进行 301 的重定向。 你所知道的3xx状态码 浏览器跟踪重定向地址再次向正确地址发送 HTTP 请求 服务器处理请求经过千辛万苦，终于将 http 发送到了我们的服务器。后端接到 TCP 报文开始，他会对 tcp 连接进行处理，对 HTTP 根据协议进行解析，按照报文格式一步一步封装成 HTTP request 对象，供上层使用。 大一点的网站会请求到反向代理中，因为网站访问量越来越大，网站速度也就变慢了，此时客户端不再直接通过 HTTP 协议访问某网站的应用服务器，而是先请求到 Nginx ， Nginx 再请求应用服务器，然后再将结果返回给客户端，这里 Nginx 的作用时反向代理服务器，同时如果一台服务器挂了，只要其他服务器还在正常运行，网站就能正常使用。 服务器返回 HTTP 请求响应类似请求： 状态行 响应头 响应体 响应状态码 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue 101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功 204 No Content 成功，但不返回任何实体的主体部分 206 Partial Content 成功执行了一个范围（Range）请求 3xx：重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 HTTP状态码HTTP response codesHTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 浏览器渲染 html浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 首先是解析 HTML 构建 DOM 树 =&gt; 解析 CSS 解析为 CSSOM =&gt; 结合 DOM 和 CSSOM 生成 render tree(每个节点的视觉信息) =&gt; 生成布局 layout =&gt; 将布局绘制到屏幕 这五步中，三四步比较慢生成布局和绘制合成渲染 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 DOM 树 DOM 树中的每一个需要显示的节点再渲染树中至少存在一个对应的节点，隐藏的 DOM 元素则没有对应节点，渲染树中的节点被称为 “帧（frames）”或“盒（boxes）”，符合 CSS 模型的定义，一旦DOM 树和渲染树构建完成，浏览器就开始显示绘制元素 很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。如果能达到每秒70帧甚至80帧，就会极其流畅。 大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。 一秒之间能够完成多少次重新渲染，这个指标就被称为”刷新率”，英文为FPS（frame per second）。60次重新渲染，就是60FPS。如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。 DOM 解析123456789101112&lt;html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DOM 解析成这样 CSS 解析假设有下面这样的 DOM 结构123456789&lt;doc&gt;&lt;title&gt;A few quotes&lt;/title&gt;&lt;para&gt; Franklin said that &lt;quote&gt;&quot;A penny saved is a penny earned.&quot;&lt;/quote&gt;&lt;/para&gt;&lt;para&gt; FDR said &lt;quote&gt;&quot;We have nothing to fear but &lt;span&gt;fear itself.&lt;/span&gt;&quot;&lt;/quote&gt;&lt;/para&gt;&lt;/doc&gt; CSS 文档1234 /* rule 1 */ doc &#123; display: block; text-indent: 1em; &#125;/* rule 2 */ title &#123; display: block; font-size: 3em; &#125;/* rule 3 */ para &#123; display: block; &#125;/* rule 4 */ [class=&quot;emph&quot;] &#123; font-style: italic; &#125; CSS Rule tree 时这样 图中的第4条规则出现了两次，一次是独立的，一次是在规则3的子结点。所以，我们可以知道，建立CSS Rule Tree是需要比照着DOM Tree来的。CSS匹配DOM Tree主要是从右到左解析CSS的Selector，好多人以为这个事会比较快，其实并不一定。关键还看我们的CSS的Selector怎么写了。 CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去 通过这俩个树我们可以得到一个叫 Style Context Tree 所以，Firefox基本上来说是通过CSS 解析 生成 CSS Rule Tree，然后，通过比对DOM生成Style Context Tree，然后Firefox通过把Style Context Tree和其Render Tree（Frame Tree）关联上，就完成了。注意：Render Tree会把一些不可见的结点去除掉。而Firefox中所谓的Frame就是一个DOM结点，不要被其名字所迷惑了。 在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法 渲染 计算 CSS 样式 构建 render tree Layout 开始绘制 上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的CSS rule没有被匹配到，等。 Repaint屏幕的一部分要重画，比如某个元素的 CSS 背景变了，但尺寸没有变 Reflow当 DOM 的变化影响了元素的几何属性 =&gt; 比如改变边框宽度或者给段落增加文字，导致行数增加 =&gt; 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会收到影响，浏览器会使渲染树中受到影响部分失效，并重新构造渲染树，发生重排，完成重排后，浏览器会重新绘制受影响部分的元素到屏幕中，也会发生重绘。 样式表越简单，重排和重绘就越快。 重排和重绘的DOM元素层级越高，成本就越高。 table元素的重排和重绘成本，要高于div元素发生重绘 当你增加、删除、修改DOM结点时，会导致Reflow或Repaint 当你移动DOM的位置，或是搞个动画的时候。(元素位置发生改变) 当你修改CSS样式的时候。或者页面渲染初始化 当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 元素尺寸发生改变(边距， 高度等) 注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。渲染树的变化的排队与刷新由于每次重排都行会产生消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程，然而，你可能会不知不觉的强制刷新对了要求计划立刻执行，获取布局的信息会导致队列刷新 offsetTop, offsetBottom, offsetWidth, offsetHeight scrollTop, scrollBottom, scrollWidth, scrollHeight clientTop, clientBottom, clientWidth, clientHeight getComputedStyle() =&gt;( currentStyle in IE)以上属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的‘待处理变化’并触发重排以返回正确的值。 “重绘”不一定需要”重排” —- “重排”必然导致”重绘” 最小化重绘和重排 改变样式 =&gt; 不要一条条地改变样式，多个改变合并 =&gt; 直接更换 CSS 的 Class 批量修改 DOM =&gt; 使元素脱离文档流(隐藏显示，使用文档片段，拷贝到一个脱离文档的节点中完成后再替换) =&gt; 修改 =&gt; 带回文档 动画使用绝对定位，使用拖放代理 缓存布局信息 =&gt; 偏移量，滚动位置， 计算出的样式等 获取一次后赋值给局部遍历 事件委托 =&gt; 减少事件处理器的数量 浏览器请求嵌在 HTML 中的资源(图片，视频音频， CSS， JavaScript 等)其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接： 图片：http://or3233yyd.bkt.clouddn.com//17-8-9/67016800.jpg CSS式样表：https://cdn.bootcss.com/animate.css/3.5.2/animate.css JavaScript 文件：https://cdn.bootcss.com/jquery/3.2.1/core.js 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等… 不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中 转载整理： 老生常谈从输入url 到页面展示到底发生了什么 当···时发生了什么？=&gt; 推荐 作为前端你不得不知-浏览器的工作原理：网络浏览器幕后揭秘 浏览器的工作原理：新式网络浏览器幕后揭秘 – more than 从输入 URL 到页面加载完成的过程中都发生了什么事情？=&gt; 太恐怖，涉及硬件，感兴趣就去挑战吧 浏览器渲染原理 网页性能管理详解","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"面试前夕","slug":"面试前夕","permalink":"http:\\\\hexin.life/tags/面试前夕/"}]},{"title":"盒模型 行内元素及块级元素区别","slug":"title-15","date":"2017-07-11T13:30:56.000Z","updated":"2017-09-09T08:25:55.464Z","comments":true,"path":"2017/07/11/title-15/","link":"","permalink":"http:\\\\hexin.life/2017/07/11/title-15/","excerpt":"","text":"盒模型.png) 在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性 — 像它的颜色，背景，边框方面 — 和位置是渲染引擎的目标。 在CSS中，使用标准盒模型描述这些矩形盒子中的每一个。这个模型描述了元素所占空间的内容。每个盒子有四个边：外边距边, 边框边, 内填充边 与 内容边。 盒模型 内容区域content area 是包含元素真实内容的区域。它通常包含背景、颜色或者图片等，位于内容边界的内部，它的大小为内容宽度 或 content-box宽及内容高度或content-box高。 如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。 内边距区域 padding area 延伸到包围padding的边框。如果内容区域 content area 设置了背景、颜色或者图片，这些样式将会延伸到 padding 上(译者注：而不仅仅是作用于内容区域)。它位于内边距边界内部, 它的大小为 padding-box 宽与 padding-box 高。 内边距与内容边界之间的空间可以由 padding-top, padding-right, padding-bottom, padding-left 和简写属性 padding 控制。 边框区域 border area 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 border-box 宽和 border-box 高。由 border-width 及简写属性 border控制。 外边距区域 margin area 用空白区域扩展边框区域，以分开相邻的元素。它的大小为 margin-box 的高宽。 外边距区域大小由 margin-top, margin-right, margin-bottom, margin-left 及简写属性 margin 控制。 盒模型宽高计算最终元素的总宽度计算公式是这样的： 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距 width = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 元素的总高度最终计算公式是这样的： 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 height = margin-top + border-top + padding-top + width + padding-bottom + border-bottom + margin-bottom 而IE对宽度的诠释不一样。符合 W3C 标准的浏览器认为一个元素的宽度只等于其 content 的宽度，其余都要额外算。如：123456.example &#123; width: 200px; padding: 10px; border: 5px solid #000; margin: 20px;&#125; 则他最终的宽度应为：宽度 = width + padding 2 + border 2 + margin * 2 = 270px; 而在 IE（低于IE9） 下，最终宽度为：宽度 = width + margin* 2 = 240px; W3C 最后为了解决这个问题，在 CSS3 中加了 box-sizing 这个属性。当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内，和 IE 之前的标准是一样的。 所以，为了避免你同一份 css 在不同浏览器下表现不同，最好加上： 12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; box-sizing标准模型 + IE 模型及区别 标准模型 只有 content 的宽高 IE 模型 包含了 border 和 padding 的宽高 CSS 如何设置这俩种模型 box-sizing: content-box 浏览器默认 box-sizing: border-box content-box默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距, 边框 &amp; 外边距 都在这个盒子的外部。 比如. 如果 .box {width: 350px}; 而且 {border: 10px solid black;} 那么在浏览器中的渲染的实际宽度将是370px; 尺寸计算公式：width = 内容的宽度，height = 内容的高度。宽度和高度都不包含内容的边框（border）和内边距（padding）。 border-boxwidth 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于Quirks模式时InternetExplorer使用的盒模型。注意，填充和边框将在盒子内 , 例如, .box {width: 350px; border:10pxsolidblack;}导致在浏览器中呈现的宽度为350px的盒子。内容框不能为负，并且被分配到0，使得不可能使用border-box使元素消失。 这里的维度计算为：width = border + padding + 内容的 width，height = border + padding + 内容的 height。 JS获取这俩种模型对应的宽和高 dom.style.width/height =&gt; 只能取出内联样式的宽高 dom.currentStyle.width/height =&gt; 渲染以后的样式 IE… window.getComputedStyle(btn).height =&gt; FireFox chrome… dom.getBoundingClientRect() =&gt; 可获得x, y, top, bottom, left, right, height, width 六个属性根据视窗(viewport)计算元素的绝对位置 根据盒模型解释边距重叠发生外边距塌陷的三种基本情况: 相邻的兄弟姐妹元素毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。例如： 12&lt;p style=&quot;margin-bottom: 30px;&quot;&gt;这个段落的下外边距被合并...&lt;/p&gt;&lt;p style=&quot;margin-top: 20px;&quot;&gt;...这个段落的上外边距被合并。&lt;/p&gt; 可以发现这两个段落中间的距离，不是 ”上面段落的下边距“ 与 ”下面段落的上边距“ 的 求和 ，而是两者中的较大者（在此示例中为30px）。 块级父元素与其第一个/最后一个子元素如果块级父元素中，不存在上边框、上内边距、内联元素、清除浮动这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个 块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此 时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。类似的，若块级父元素的 margin-bottom 与它的最后一个子元素的margin-bottom 之间没有父元素的 border、padding、inline content、height、min-height、 max-height 分隔时，就会发生 下外边距合并 现象。 空块元素如果存在一个空的块级元素，其 border、padding、inline、content、height、min-height都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。例如： 123&lt;p style=&quot;margin-bottom: 0px;&quot;&gt;这个段落的和下面段落的距离将为20px&lt;/p&gt;&lt;div style=&quot;margin-top: 20px; margin-bottom: 20px;&quot;&gt;&lt;/div&gt;&lt;p style=&quot;margin-top: 0px;&quot;&gt;这个段落的和上面段落的距离将为20px&lt;/p&gt; 当以上情形同时出现时，外边距合并会更加复杂（会比较两个以上外边距来最终计算出真实的边距值）。 即使外边距为0，这些规则也仍旧生效。因此，无论父元素的外边距是否为0，第一个或者最后一个子元素的外边距会被父元素的外边距”截断”( 根据上面的规则)，在负外边距的情况下，合并后的外边距为最大正外边距与最小负外边距之和。 当有负边距存在时，合并后的外边距将是最大正边距加上最小负边距（即负边距中绝对值最大的一个）。 如两个兄弟元素，上面的元素的下边距为 20px ，下面的元素的上边距为 -20px ，那么发生外边距合并后，这两个元素的实际距离将变成 0px 。 BFC会阻止元素外边距合并。 BFC / IFC =&gt; 块级格式化上下文 / 内联元素的格式化上下文BFC 原理：(渲染原理) BFC 元素的垂直方向的边距会发生重叠 BFC 这个元素不会与浮动元素的 box 重叠，清除浮动 独立的容器，外面元素和里面元素互不影响 计算 BFC 高度时，浮动元素也会参与计算 如何创建 BFC 设置浮动 position 值不为 static relative display table / table-cell / table-caction overflow hidden auto BFC 使用场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!-- BFC 垂直方向边距重叠 --&gt; &lt;section id=&quot;sec&quot;&gt; &lt;style&gt; html,body&#123; padding: 0; margin: 0; &#125; #sec&#123; background: yellow; /* 增加 overflow: hidden 解决边距重叠*/ overflow: hidden; &#125; .child&#123; height: 100px; margin-top: 10px; background: #f00; &#125; &lt;/style&gt; &lt;article class=&quot;child&quot;&gt; &lt;/article&gt; &lt;/section&gt; &lt;!-- BFC 垂直方向边距重叠 --&gt; &lt;section id=&quot;margin&quot;&gt; &lt;style&gt; #margin &#123; background: pink; overflow: hidden; &#125; #margin&gt;p &#123; margin: 5px auto 25px; background: red; &#125; &lt;/style&gt; &lt;p&gt;1&lt;/p&gt; &lt;!-- 增加父级元素设置 overflow 建立 BFC 取消边距重叠 --&gt; &lt;div style=&quot;overflow: hidden;&quot;&gt; &lt;p&gt;2&lt;/p&gt; &lt;/div&gt; &lt;p&gt;3&lt;/p&gt; &lt;/section&gt; &lt;!-- BFC 不与浮动元素重叠 --&gt; &lt;section id=&quot;layout&quot;&gt; &lt;style&gt; #layout &#123; margin-top: 20px; background: green; &#125; #layout .left &#123; float: left; width: 100px; height: 100px; background: pink; &#125; #layout .right &#123; height: 110px; background: blue; /* 增加 overflow: auto; .left 重叠消失 */ overflow: auto; &#125; &lt;/style&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;!-- BFC 子元素即使是 float 也会参与高度计算 --&gt; &lt;section id=&quot;float&quot;&gt; &lt;style&gt; #float &#123; margin-top: 20px; background: blue; /* 设置浮动 非none / overflow: auto / hidden，父级元素高度参与计算，原为 0 */ float: left; /*overflow: hidden;*/ /*overflow: auto;*/ &#125; #float .float &#123; float: left;; font-size: 30px; &#125; &lt;/style&gt; &lt;div class=&quot;float&quot;&gt; 我是浮动元素 &lt;/div&gt; &lt;/section&gt; 浏览器的兼容性问题 一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性设。解决 IE8 及更早版本不兼容问题可以在HTML页面声明 &lt; !DOCTYPE html &gt; 即可。 IE6中浮动双边距因为内联元素没有此问题，所以通过设置 display:inline 解决 行内元素及块级元素HTML (超文本标记语言) 元素大多数都是行内元素或块级元素。 行内元素只占据它对应标签的边框所包含的空间。 块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。行内元素 内容 一般情况下，行内元素只能包含数据和其他行内元素。 格式 行内元素不会以新行开始 块级元素会新起一行。 &gt; 设置宽度width 无效。 设置高度height 无效，可以通过 line-height 来设置。 设置 margin 只有左右 margin 有效，上下无效。 设置 padding 只有左右 padding 有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的. 如果你要将行内元素变成块级元素，那么就只需要在该标签上加上样式 1display:block; 块级元素可以用样式控制其高、宽的值。 若既想让元素在行内显示，又能设置宽高1display: inline-block 行内元素不可以控制宽和高，除非你想将它转变成为块级元素。它的宽和高，是随标签里的内容而变化。 行内元素列表 b, big, i, small, tt abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var a, bdo, br, img, map, object, q, script, span, sub, sup button, input, label, select, textarea 块级元素用法 块级元素只能出现在 元素内 内容 块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。 格式 默认情况下，块级元素会新起一行。 内容模型 一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。块级元素列表 article [HTML5] 文章内容。 aside [HTML5] 伴随内容。 audio [HTML5] 音频播放。 blockquote 块引用。 canvas [HTML5] 绘制图形。 dd 定义列表中定义条目描述。 div 文档分区。 dl 定义列表。 fieldset 表单元素分组。 figcaption [HTML5] 图文信息组标题 figure [HTML5] 图文信息组 (参照 figcaption)。 footer [HTML5] 区段尾或页尾。 form 表单。 h1, h2, h3, h4, h5, h6 标题级别 1-6. header [HTML5] 区段头或页头。 hgroup [HTML5] 标题组。 hr 水平分割线。 noscript 不支持脚本或禁用脚本时显示的内容。 ol 有序列表。 output [HTML5] 表单输出。 p 行。 pre 预格式化文本。 section [HTML5] 一个页面区段。 table 表格。 tfoot 表脚注。 ul 无序列表。 video [HTML5] 视频。 可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object 对象 script - 客户端脚本 参考 CSS块级元素和行内元素-晚晴幽草轩 MDN -行内元素 CSS 最核心的几个概念","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http:\\\\hexin.life/tags/CSS/"}]},{"title":"关于CSS 缓动(转)","slug":"title-14","date":"2017-07-11T12:28:04.000Z","updated":"2017-07-13T06:29:19.777Z","comments":true,"path":"2017/07/11/title-14/","link":"","permalink":"http:\\\\hexin.life/2017/07/11/title-14/","excerpt":"","text":"缓动的基础知识自然界中没有东西是从一点呈线性地移动到另一点。现实中，物体在移动时往往会加速或减速。我们的大脑习惯于期待这种运动，因此在做动画时，应利用此规律。自然的运动会让用户对您的应用感觉更舒适，从而产生更好的总体体验。 缓动使您的动画感觉更自然。 为 UI 元素选择缓出动画。 避免缓入或缓入缓出动画，除非可以使其保持简短；这类动画可能让最终用户觉得很迟钝。 在经典动画中，缓慢开始然后加速的动画术语是“慢入”，快速开始然后减速的动画被称为“慢出”。网络上对于这些动画最常用的术语分别是“缓入”和“缓出”。有时两种动画相组合，称为“缓入缓出”。缓动实际上是使动画不再那么尖锐或生硬的过程。 缓动关键字CSS 变换和动画都允许您选择要为动画使用的缓动类型。您可以使用影响相关动画的缓动（或有时称为 timing）的关键字。还可以完全自定义您的缓动，借此方式更自由地表达应用的个性。 以下是可在 CSS 中使用的一些关键字： linear ease-in ease-out ease-in-out资料来源：CSS 变换，W3C 还可以使用 steps 关键字，它允许您创建具有离散步骤的变换，但上面列出的关键字对于创建感觉自然的动画最有用，并且这绝对是您要的效果。 线性动画 没有任何缓动的动画称为线性动画。线性变换的图形看起来像这样： 随着时间推移，其值以等量增加。采用线性运动时，动画内容往往显得很僵硬，不自然，让用户觉得不协调。一般来说，应避免线性运动。 不管通过 CSS 还是 JavaScript 来编写动画代码，您将发现始终有线性运动的选项。 查看线性动画 要通过 CSS 实现上述效果，代码将类似下面这样：1transition: transform 500ms linear; 缓出动画 缓出使动画在开头处比线性动画更快，还会在结尾处减速。 缓出一般最适合界面，因为开头时快速使动画有反应快的感觉，同时在结尾仍允许有一点自然的减速。查看缓出动画 有很多方法来实现缓出效果，但最简单的方法是 CSS 中的 ease-out 关键字：1transition: transform 500ms ease-out; 缓入动画 缓入动画开头慢结尾快，与缓出动画正好相反。 这种动画像沉重的石头掉落一样，开始时很慢，然后快速地重重撞击地面，突然沉寂下来。 但是，从交互的角度来看，缓入可能让人感觉有点不寻常，因为结尾很突然；在现实中移动的物体往往是减速，而不是突然停止。缓入还有让人感觉行动迟缓的不利效果，这会对网站或应用的响应速度给人的感觉产生负面影响。 查看缓入动画 要使用缓入动画，与缓出和线性动画类似，可以使用其关键字：1transition: transform 500ms ease-in; 缓入缓出动画 缓入并缓出与汽车加速和减速相似，使用得当时，可以实现比单纯缓出更生动的效果。 由于缓入开头让动画有迟钝感，因此动画持续时间不要过长。300-500 毫秒的时间范围通常比较合适，但实际的数量主要取决于项目的感觉。也就是说，由于开头慢、中间快和结尾慢，动画将有更强的对比，可能让用户感到非常满意。查看缓入缓出动画要设置缓入缓出动画，可以使用 ease-in-out CSS 关键字：1transition: transform 500ms ease-in-out;","categories":[{"name":"转载","slug":"转载","permalink":"http:\\\\hexin.life/categories/转载/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http:\\\\hexin.life/tags/转载/"}]},{"title":"定制 hexo","slug":"title-11","date":"2017-06-06T03:48:42.000Z","updated":"2017-06-06T16:41:35.945Z","comments":true,"path":"2017/06/06/title-11/","link":"","permalink":"http:\\\\hexin.life/2017/06/06/title-11/","excerpt":"","text":"时隔好久，这里对hexo的博客进行一些功能上的拓展 1.七牛云定制空间及绑定到极简图床 对于上传图片个人喜欢极简图床，支持复制粘贴上传，截图然后粘贴用起来贼爽。 极简图窗对于游客每日只有10张图片的上限，开始觉得够用了，但是玩着玩着就没了。不过，他本身提供了七牛云的空间储存。 注册和邮箱验证这里就不赘述了，自行解决吧。 完成之后选择新建仓库名字建议写成小写，他好像是默认小写的。 然后到个人中心找到密钥分别填入 找到仓库下的图片处理位置，绑定的域名使用七牛提供的域名即可 此时就拥有了10G的七牛免费储存空间，极简图床也不限制次数了。慢慢享用吧骚年。 2.HEXO 内容压缩 我这里使用的 NEXT 主题，它在生成 HTML 时由于主题的简洁，形成了大量留白，反而增大了文件大小，使得本来服务器就在国外的网站加载更慢。 1.这里使用当红小生 gulp 进行文件的处理。 HEXO 在根目录下新建 gulpfile.js 文件 我们对文件处理需要用到 gulp 的一些插件 使用 npm install ** –save-dev 来下载这些插件并保存，添加到 package.json 配置项中。 由于 npm 服务器在国外下载较慢，安装淘宝镜像 cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 然后配置 gulpfile.js ,我们知道我们提交博客时，是将静态文件生成到 public 下，然后提交到 github 的。所以我们对文件处理时，就处理这里的静态文件即可。静态文件树形图如下（太长我删减了一部分）： D:. public/ ├─2017 │ ├─03 │ ├─28 │ └─title-1 │ ├─about ├─archives │ ├─2017 │ │ ├─03 │ │ ├ │ │ └─pages │ │ ├─2 │ │ └─3 │ └─pages │ ├─2 │ └─3 ├─assets │ └─js ├─categories │ ├─css │ ├─hexo │ ├─JavaScript │ ├─window │ ├─其他 │ └─前端 ├─css ├─images ├─js │ └─src │ └─schemes ├─lib │ ├─algolia-instant-search │ ├─canvas-nest │ ├─fancybox │ │ └─source │ │ └─helpers │ ├─fastclick │ │ └─lib │ ├─font-awesome │ │ ├─css │ │ └─fonts │ ├─jquery │ ├─jquery_lazyload │ ├─three │ ├─ua-parser-js │ │ └─dist │ └─velocity ├─pages │ ├─2 │ └─3 └─tags ├─css-前端 ├─CSS学习笔记 ├ └─转载 1.因此对文件处理的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 引入插件 const gulp = require('gulp'), Hexo = require('hexo'), pump = require('pump'), clean = require('gulp-clean'), jsmin = require('gulp-jsmin'), // rename = require('gulp-rename'), htmlmin = require('gulp-htmlmin'), imagemin = require('gulp-imagemin'), cleanCSS = require('gulp-clean-css'), imageminSvgo = require('imagemin-svgo'), imageminJpegtran = require('imagemin-jpegtran'), imageminPngquant = require('imagemin-pngquant');// 利用Hexo API 来生成博客内容，效果同在命令行运行：hexo g // generate html with 'hexo generate'var hexo = new Hexo(process.cwd(), &#123;&#125;);gulp.task('generate', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('generate', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; console.log(err); hexo.exit(err); return cb(err); &#125;)&#125;)//压缩 js 文件gulp.task('jsmin', () =&gt; gulp.src('./public/js/src/**/*.js') .pipe(jsmin()) //.pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest('./public/js')););//压缩 html 文件gulp.task('htmlmin', () =&gt; gulp.src('./public/**/**/**/*.html') .pipe(htmlmin(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest('./public')););// 压缩图片gulp.task('imagemin', () =&gt; gulp.src('./public/images/*') .pipe(imagemin()) .pipe(gulp.dest('./public/images')));imagemin(['./public/images/*.&#123;jpg,png&#125;'], './public/imagess', &#123; plugins: [ imageminJpegtran(), imageminPngquant(&#123;quality: '65-80'&#125;) ]&#125;); imagemin(['./public/images/*.svg'], './public/images', &#123; use: [ imageminSvgo(&#123; plugins: [ &#123;removeViewBox: false&#125; ] &#125;) ]&#125;)//压缩 cssgulp.task('minify-css',() =&gt; gulp.src('./public/css/*.css') .pipe(cleanCSS(&#123;compatibility: 'ie8'&#125;)) .pipe(gulp.dest('./public/css')));//默认任务gulp.task('default',[\"generate\",\"minify-css\",\"jsmin\",\"htmlmin\",\"imagemin\"], function() &#123; console.log('gulp is finished!');&#125;)// gulp.task(\"watch\",function() &#123;// gulp.watch(\"public/*\",[\"default\"]);// &#125;); 之后命令行运行 gulp 即可压缩.因为将生成静态文件的步骤hexo generate 集成到了 gulp 中，所以我们以后可以先 gulp 然后 hexo deploy 提交。 输出如下： 效果如图： 参考： 优化Hexo博客 - 压缩 HTML、CSS、JS、IMG等 3. 添加音乐外链 如果想在看博客的时候听一些喜欢的音乐怎么办呢？ 1. 可以直接在 markdown 中写入 HTML 代码（网易云，虾米均支持外链）1. embed 1&lt;embed src=\"//music.163.com/style/swf/widget.swf?sid=452986458&amp;type=2&amp;auto=1&amp;width=320&amp;height=66\" width=\"340\" height=\"86\" allowNetworking=\"all\"&gt;&lt;/embed&gt; 2. javascript&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xiami.com/widget/player-single?uid=93773004&amp;sid=1769292418&amp;mode=js&quot;&gt;&lt;/script&gt; 3. iframe1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=452986458&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 5. HEXO 的插件 aplayer / dplayer (没有用过就不多说了) hexo-tag-aplayer:https://github.com/grzhan/hexo-tag-aplayer#upstream-issuehexo-tag-dplayer:https://github.com/NextMoe/hexo-tag-dplayer 2. 将音乐框添加到 slideBar 其实方式是一样的，将外链的代码 粘贴到你要显示的地方即可,如图： 1. 点击出现心型特效，及背景线条 1. 心型特效代码 love.js123456789!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:.8,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2.背景特效代码 par.js 12345678 !function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(\"script\"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,\"zIndex\",-1),o:n(i,\"opacity\",.5),c:n(i,\"color\",\"0,0,0\"),n:n(i,\"count\",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=\"rgba(\"+m.c+\",\"+(t+.2)+\")\",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(\"canvas\"),m=t(),d=\"c_n\"+m.l,l=u.getContext(\"2d\"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=\"position:fixed;top:0;left:0;z-index:\"+m.z+\";opacity:\"+m.o,e(\"body\")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 4. 其他特效如头像旋转等 直接如图： 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 50%; box-shadow: inset 0 -1px 0 #333sf; -webkit-border-radius: 50%; -moz-border-radius: 50%; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1s ease-out; -moz-transition: -moz-transform 1s ease-out; transition: transform 1s ease-out;&#125; 123456img:hover&#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 做自己喜欢的事情才会有动力","categories":[{"name":"hexo","slug":"hexo","permalink":"http:\\\\hexin.life/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http:\\\\hexin.life/tags/hexo/"}]},{"title":"欢迎来到 cmder","slug":"title-10","date":"2017-06-05T17:01:56.000Z","updated":"2017-07-11T10:10:20.714Z","comments":true,"path":"2017/06/06/title-10/","link":"","permalink":"http:\\\\hexin.life/2017/06/06/title-10/","excerpt":"","text":"咸鱼也得做特别咸的那种 $ 最近电脑受不了了，折腾比较多,对于好多东西装了N次，在这里简单记录一下。$ win 下命令行神器 cmder在 win 下 的命令行神器 cmder，原始 cmd 难看不说，功能也少，这里推荐一下 cmder。可以直接下载 mini 版本，只有 6 mb 大小，完整版本包含了 git 等一堆功能，git 已经安装过了， 这里我就选择了 Mini 版。 安装很简单，直接下载解压即可使用 不过为了方便，我们添加一下环境变量。 即可 Win + R 输入 cmder 唤出。 但是呢，好像还是不够方便，此时我们可以将它添加到我们的鼠标右键，像 git 巴蜀 here 那样。打开 cmder 终端输入下面命令 1Cmder.exe /REGISTER ALL //如果没有权限 则输入 Cmder.exe /REGISTER USER 然后是去除文字重叠， win + alt + p 或者点右下角图标选择设置 setting . 然后将 monospace 前面的对勾去掉即可。 如果习惯 git 里面的 \\$ 符号的话。可以打开 D:\\cmder_mini\\vendor\\clink.lua 找到44行左右，将 符号改为 \\$ 效果如图： 基本目前所需要的功能差不多就这样。 晚晴幽草轩轩主","categories":[{"name":"window","slug":"window","permalink":"http:\\\\hexin.life/categories/window/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http:\\\\hexin.life/tags/其他/"}]},{"title":"px、em和rem","slug":"title-9","date":"2017-05-23T14:06:40.000Z","updated":"2017-07-29T08:23:53.139Z","comments":true,"path":"2017/05/23/title-9/","link":"","permalink":"http:\\\\hexin.life/2017/05/23/title-9/","excerpt":"","text":"再牛逼的梦想也挡不住傻逼似的坚持 ~ –菜鸟教程 &gt; 偶然遇到一个原生JS去除 className 的技巧 Element.className.replace(‘testClassName’, ‘realClassName’);px px : 相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 特点 : IE无法调整那些使用px作为单位的字体大小； 国外的大部分网站能够调整的原因在于其使用了 em 或 rem 作为字体单位； Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。emem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 em的值并不是固定的； em会继承父级元素的字体大小。 123456789101112html &#123; font-size: 20px; /* 20px */&#125; .level-1&#123; font-size: 0.5em; /* 10px */&#125; .level-2&#123; font-size: 2em; /* 20px */&#125;.level-3 &#123; font-size: 0.5em; /* 10px */&#125; rem rem是CSS3新增的一个相对单位（root em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。123456789101112html &#123; font-size: 20px; /* 20px */&#125; .level-1&#123; font-size: 0.5rem; /* 10px */&#125; .level-2&#123; font-size: 2rem; /* 40px */&#125;.level-3 &#123; font-size: 0.5rem; /* 10px */&#125; 对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。1p &#123;font-size:14px; font-size:.875rem;&#125; 注意： 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。px 与 rem 的选择？对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。对于需要适配各种移动设备，则使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。 px、em、rem的区别及介绍-菜鸟教程","categories":[{"name":"css","slug":"css","permalink":"http:\\\\hexin.life/categories/css/"}],"tags":[{"name":"css 前端","slug":"css-前端","permalink":"http:\\\\hexin.life/tags/css-前端/"}]},{"title":"copy小插件","slug":"title-8","date":"2017-05-06T07:12:20.000Z","updated":"2017-07-29T08:22:28.362Z","comments":true,"path":"2017/05/06/title-8/","link":"","permalink":"http:\\\\hexin.life/2017/05/06/title-8/","excerpt":"","text":"hacker 是擅于解决问题的人 copy小插件昨天舍友在写一个报告的时候，准确的来说是从网上搜罗~然而在 360doc 看到了一个满意的，无奈下载不了，也没法复制粘贴，于是就试了一下。 然后我打开开发者工具(F12)一行代码搞定12//document.getElementsByTagName('body')[0].oncopy = null;document.getElementsByTagName('body')[0].oncopy = ''; //获取body元素的oncpoy事件，直接置空~ 虽然很简单，但是还了一个页面它就失效了，可以再次打开开发者工具，再次置空就行了有更好的办法或者一劳永逸的办法~希望大神指教一下 这是从网上搜到的 chrome 插件的核心代码，制空 copy 事件，并取消页面复制粘贴等冒泡事件123456789101112131415161718192021(function oncopy () &#123; document.getElementsByTagName(body)[0].oncopy = '';&#125;)();document.addEventListener(\"paste\", function (event) &#123; event.stopPropagation();&#125;, true); // true - 事件句柄在捕获阶段执行//for re-enabling 'copy'document.addEventListener(\"copy\", function (event) &#123; event.stopPropagation();&#125;, true);//for re-enabling 'cut'document.addEventListener(\"cut\", function (event) &#123; event.stopPropagation();&#125;, true);//for re-enabling 'right-clicks'document.addEventListener(\"contextmenu\", function(event)&#123; event.stopPropagation();&#125;, true);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http:\\\\hexin.life/categories/JavaScript/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http:\\\\hexin.life/tags/插件/"}]},{"title":"JS函数闭包","slug":"title-7","date":"2017-04-15T13:03:54.000Z","updated":"2017-05-04T15:37:52.487Z","comments":true,"path":"2017/04/15/title-7/","link":"","permalink":"http:\\\\hexin.life/2017/04/15/title-7/","excerpt":"","text":"程序是写给人看的，顺带能在机器上运行 JS循环闭包：应用一html 结构12345 &lt;p&gt;test0&lt;/p&gt;&lt;p&gt;test1&lt;/p&gt;&lt;p&gt;test2&lt;/p&gt;&lt;p&gt;test3&lt;/p&gt;&lt;p&gt;test4&lt;/p&gt; 抛出问题123456789101112131415/* 抛出问题: 此题的目的是想每次点击对应目标时弹出对应的数字下标 0~4,但实际是无论点击哪个目标都会弹出数字5 问题所在: arr 中的每一项的 onclick 均为一个函数实例(Function 对象),这个函数实例也产生了一个闭包域, 这个闭包域引用了外部闭包域的变量,其 function scope 的 closure 对象有个名为 i 的引用, 外部闭包域的私有变量内容发生变化,内部闭包域得到的值自然会发生改变 */ function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = function () &#123; alert(i); //无论点击哪一个均会弹出5 &#125; &#125; &#125; 方法一：12345678910111213解决方法一： 增加若干个对应的闭包域空间( 这里采用的是匿名函数),专门用来存储原先需要引用的内容(下标),不过只限于基本类型(基本类型值传递,对象类型引用传递) function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; arr.length; i++) &#123; (function (j) &#123; arr[i].onclick = function () &#123; alert(j); &#125; &#125;)(i); &#125; &#125; 方法二123456789101112/*思路：将下标作为对象属性(name:\"i\",value:i的值)添加到每个数组项(p对象)中*/此时当前 p 对象的 i 属性并不是对循环体的 i 变量的引用,而是一个独立 p 对象的属性,属性值在声明的时候就确定了(基本类型的值都是存在栈中的,当有一个基本类型变量声明其等于另一个基本变量时,此时并不是两个基本类型变量都指向一个值,而是各自有各自的值,但值是相等的) function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].i = i; arr[i].onclick = function () &#123; alert(this.i); &#125; &#125; &#125; 方法三1234567891011121314151617/*解决思路:与解决办法一有点相似但却有点不太相似.相似点:同样是增加若干个对应的闭包域空间用来存储下标不同点:解决办法一是在新增的匿名闭包空间内完成事件的绑定,而此例是将事件绑定在新增的匿名函数返回的函数上。此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg*/ function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = (function (j) &#123; return function ()&#123; alert(j); &#125; &#125;)(i); &#125; &#125; 方法四12345678910111213 //思路同方法一： function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; arr.length; i++) &#123; (function()&#123; var tmp = i; arr[i].onclick = function () &#123; alert(tmp); &#125; &#125;)(); &#125;&#125; 方法五：12345678910//方法五：es6新语法，let为一个块级作用域 function myClosure() &#123; var arr = document.getElementsByTagName(\"p\"); for (let i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = function () &#123; alert(i); &#125; &#125; &#125; 非循环闭包：应用一：html 结构12345678910&lt;p id=\"help\"&gt;Helpful notes will appear here&lt;/p&gt; &lt;p&gt;E-mail: &lt;input type=\"text\" id=\"email\" name=\"email\"&gt; &lt;/p&gt; &lt;p&gt;Name: &lt;input type=\"text\" id=\"name\" name=\"name\"&gt; &lt;/p&gt; &lt;p&gt;Age: &lt;input type=\"text\" id=\"age\" name=\"age\"&gt; &lt;/p&gt; 闭包解决 input 框聚焦动态提示1234567891011121314151617181920212223242526272829function showHelp(help) &#123; document.getElementById('help').innerHTML = help; &#125; function makeHelpCallback(help) &#123; return function() &#123; //形成闭包 showHelp(help); &#125;; &#125; function setupHelp() &#123; var helpText = [&#123; 'id': 'email', 'help': 'Your e-mail address' &#125;, &#123; 'id': 'name', 'help': 'Your full name' &#125;, &#123; 'id': 'age', 'help': 'Your age (you must be over 16)' &#125;]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125; &#125; setupHelp(); 应用二html 结构1234567&lt;p&gt;Some paragraph text&lt;/p&gt;&lt;h1&gt;some heading 1 text&lt;/h1&gt;&lt;h2&gt;some heading 2 text&lt;/h2&gt;&lt;a href=\"#\" id=\"size-12\"&gt;12&lt;/a&gt;&lt;a href=\"#\" id=\"size-14\"&gt;14&lt;/a&gt;&lt;a href=\"#\" id=\"size-16\"&gt;16&lt;/a&gt; css123456789101112131415161718192021222324 body &#123; font-family: Helvetica, Arial, sans-serif; font-size: 12px;&#125;h1 &#123; font-size: 1.5em;&#125;h2 &#123; font-size: 1.2em;&#125;```javascript function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;; &#125; var size12 = makeSizer(12); var size14 = makeSizer(14); var size16 = makeSizer(16); document.getElementById('size-12').onclick = size12; document.getElementById('size-14').onclick = size14; document.getElementById('size-16').onclick = size16; From: 闭包-MDN 9种办法解决JS循环闭包面试经典题之for循环","categories":[],"tags":[]},{"title":"HTML 5 Web 存储及WEB应用缓存","slug":"title-6","date":"2017-04-15T12:51:20.000Z","updated":"2017-04-18T11:54:03.333Z","comments":true,"path":"2017/04/15/title-6/","link":"","permalink":"http:\\\\hexin.life/2017/04/15/title-6/","excerpt":"","text":"俩种在客户端储存数据的方法 localStorage - 没有时间限制的数据存储 sessionStorage - 针对 session 的数据存储 之前这些都是由cookie完成的，但是cookie不适合大量数据的存储，因为他们由每个服务器的请求来传递，使得cookie速度慢而且效率不高。 在HTML5中，数据不是由每个服务器请求来传递的，而是只有在请求时使用数据，使得在不影响网站性能的情况下存储大量数据。对于不同的网站，sh数据存储于不同的区域，而且一个网站只能访问其自身的数据。HTML5 通过JavaScript来存储和访问数据。 #localStorage 方法 例子对用户访问页面的次数进行计数： 1234567891011&lt;script type=\"text/javascript\"&gt;if (localStorage.pagecount) &#123; localStorage.pagecount=Number(localStorage.pagecount) +1; &#125;else &#123; localStorage.pagecount=1; &#125;document.write(\"Visits \"+ localStorage.pagecount + \" time(s).\");&lt;/script&gt; sessionStorage 方法 sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 对用户在当前 session 中访问页面的次数进行计数1234567891011&lt;script type=\"text/javascript\"&gt;if (sessionStorage.pagecount) &#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; &#125;else &#123; sessionStorage.pagecount=1; &#125;document.write(\"Visits \"+sessionStorage.pagecount+\" time(s) this session.\");&lt;/script&gt; HTML 5 应用程序缓存 使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 什么是应用程序缓存（Application Cache）？ HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览：用户可在应用离线时使用它们 速度：已缓存资源加载得更快 减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持 所有主流浏览器均支持应用程序缓存，除了Internet Explorer。 如需启用应用程序缓存，请在文档的 标签中包含 manifest 属性：1234&lt;!DOCTYPE HTML&gt;&lt;html manifest=\"demo.appcache\"&gt;//something&lt;/html&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。manifest 文件的建议的文件扩展名是：”.appcache”。请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 12NETWORK:login.asp 2.NETWORK ：在此标题下列出的文件需要与服务器的连接，且不会被缓存 12345NETWORK: # NETWORK 小节规定文件 \"login.asp\" 永远不会被缓存，且离线时是不可用的：login.asp /*------------------------------*/NETWORK:* #可以使用星号来指示所有其他资源/文件都需要因特网连接： 3. FALLBACK：在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 12FALLBACK:/html5/ /404.html #第一个 URI 是资源，第二个是替补。 HTML5 Web应用程序缓存-w3school","categories":[],"tags":[{"name":"[object Object]","slug":"object-Object","permalink":"http:\\\\hexin.life/tags/object-Object/"}]},{"title":"cookie和session","slug":"title-5","date":"2017-04-15T05:53:19.000Z","updated":"2017-04-18T11:53:51.330Z","comments":true,"path":"2017/04/15/title-5/","link":"","permalink":"http:\\\\hexin.life/2017/04/15/title-5/","excerpt":"相信你所相信的，坚持你所坚持的 cookies HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？即大多都是利用 cookie、session 实现。如浏览器自动保存密码，记住登录状态，网页换肤，新手引导等下次不再提醒功能（我就说我以前换网吧玩总得去禁用那些引导）。比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？因此产生了 cookie 来解决这门问题。","text":"相信你所相信的，坚持你所坚持的 cookies HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？即大多都是利用 cookie、session 实现。如浏览器自动保存密码，记住登录状态，网页换肤，新手引导等下次不再提醒功能（我就说我以前换网吧玩总得去禁用那些引导）。比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？因此产生了 cookie 来解决这门问题。 服务器向客户端发送 cookies 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookies 的格式为vlaue = name 格式，且必须包含这部分 浏览器将 cookies 保存 每次浏览器向服务器发送请求都会发送 cookies cookies参数 httpOnly:浏览器下不允许脚本操作document.cookies去更改 cookies,一般情况下设置为 true，可以避免 xss 攻击拿到 cookies path: 表示 cookies 影响到的路径，匹配该路径才会发送 cookies expires、maxAge: 告诉浏览器该 cookies 什么时候过期，采用UTC格式的时间，是 cookies 多久后过期的相对时间。（删除 cookies，在服务端将 maxAge 设为0，或者在客户端将 expires 设为一个过去的时间），如果不设置这俩个选项，会产生 session cookies，session cookies 是即时的，当用户关闭浏览器时，会自动清除，一般用来保存 session 的 session_id.cookies的缺点 大小和数目被确定，浏览器对一个域的cookies有上限要求，且每个 cookies 大小不得超过 4kb。 存在安全性问题，容易被人拦截。（考虑到安全方面，应使用较安全的session） 需要指定域，不能够跨域 cookies 数据太多会影响传输效率，浪费带宽 有些浏览器禁用 cookies 或者部分手机不支持 cookies广告商可以通过cookies了解到用户经常访问哪些网站，进而提供相应的广告等。 session cookies 虽然使用方便,但是 cookies 中所有的数据都可以在客户端被更改，数据很容易被伪造，因此一些重要的数据不能放cookies 中，cookies 数据太多也会影响传输效率，因此产生了 session，session 数据保留在服务器端。(但是当访问增多，会比较占用服务器的性能，考虑到性能方面，减少使用session) 当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中对比取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。此时用户禁用cookies，session也会失效。 但是session并不是完全依赖cookie，服务器可以通过URL重写的方式来传递session_id. ———- &gt; 整理自： cookies 和 session cookies 和 session 的详解 cookie 和 session 的机制与安全 认识cookie与session的区别与应用","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http:\\\\hexin.life/tags/HTTP/"}]},{"title":"每个人都需要的中文排版指南（转）","slug":"title-4","date":"2017-04-11T12:06:00.000Z","updated":"2017-05-10T16:26:39.135Z","comments":true,"path":"2017/04/11/title-4/","link":"","permalink":"http:\\\\hexin.life/2017/04/11/title-4/","excerpt":"前几天被朋友吐槽排版太烂了，今天偶然看到这篇文章，然后就转载了过来，由于转载原因可能文章没有原文格式美观，有兴趣请点击链接查看原文。 原文转载自stormzhang","text":"前几天被朋友吐槽排版太烂了，今天偶然看到这篇文章，然后就转载了过来，由于转载原因可能文章没有原文格式美观，有兴趣请点击链接查看原文。 原文转载自stormzhang 相信你所相信的，坚持你所坚持的 每个人都需要的中文排版指南 之前有不少人在我公众号留言，说看我的排版很舒服，求指导。 我不是一个专业的写字人，我是程序员出身，在写代码的时候有点小洁癖，尽量会把每个细节做到更好，所以我在公众号写作的时候一样会注重每个细节，我认为排版是对写作最基本的要求，所以当我决定要在公众号写作的时候，就非常在意排版，并且一直在改进， 可惜的是，我看到无数不管是写博客还是写公众号的作者，从不会注意自己的排版，有时候看到一篇好的文章，如果排版很烂，会觉得很可惜。 公众号「小道消息」的作者 Fenng曾不止一次强调排版的重要性，对此我也非常认同，任何说不拘小节，注重内容就行了的反驳都是借口，我自己在我的小密圈中也一直强调排版的重要性，很多圈友发布的动态无一排版都太烂，为此，我在小密圈中写下了这么一篇排版指南，真心希望所有的写字人都能注意下自己的排版。 这篇文章适用于所有编辑、作家、撰稿人、公众号作者、博主等，甚至适合所有人，因为人的一生难免避免不了写作。 1. 空格 我每次看到网页上的中文字和英文、数字、符号挤在一起，就会坐立不安，忍不住想在他们之间加个空格。 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 2. 标点 说到标点，不得不说下全角和半角，很多人可能不了解全角和半角的概念，这里顺便介绍下。 全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点，中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号「我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号」。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 3. 其他 除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 这点可能有人不同意，但是我要在这里解释下，在说明之前我们必须弄明白「首行缩进」的目的是什么。 「每段之前空两格」是我们从小学写作文就养成的习惯，也是正式文体的格式要求，其目的是为了区分自然段。 但是像我们现在接触的阅读，都是没有固定的格式要求的，如微信公众号、电子文档等，所以大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 所以，我认为这种应该是最科学的方式，只要没有明确的格式要求，写作的排版无须首行缩进。 最后，你可能会问，以上这些原则是业界标准么？我不敢保证，但是你不妨看下 「Apple 中国官网」、「Microsoft中国官网」、公众号「小道消息」、「MacTalk」等的排版，基本都是使用以上排版标准。","categories":[{"name":"其他","slug":"其他","permalink":"http:\\\\hexin.life/categories/其他/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http:\\\\hexin.life/tags/转载/"}]},{"title":"CSS学习笔记(Placeholder及CSS_hack)","slug":"title-2","date":"2017-03-31T15:09:45.000Z","updated":"2017-04-15T05:39:55.256Z","comments":true,"path":"2017/03/31/title-2/","link":"","permalink":"http:\\\\hexin.life/2017/03/31/title-2/","excerpt":"相信你所相信的，坚持你所坚持的 IE8以下图片出现蓝色边框123img&#123; border:0; /*或者border:none;*/ &#125; 如何使文本以大写字母开头？1text-transform:capitalize; 强制设置以最新版本IE渲染12&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; //我写的页面在IE8之下全部乱掉了，用这个强制用最新版本的IE渲染 chrome浏览器点击input框时出现边框12//虽然我觉得还挺好看的--! input&#123; outline:none; //outline:0; &#125;","text":"相信你所相信的，坚持你所坚持的 IE8以下图片出现蓝色边框123img&#123; border:0; /*或者border:none;*/ &#125; 如何使文本以大写字母开头？1text-transform:capitalize; 强制设置以最新版本IE渲染12&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; //我写的页面在IE8之下全部乱掉了，用这个强制用最新版本的IE渲染 chrome浏览器点击input框时出现边框12//虽然我觉得还挺好看的--! input&#123; outline:none; //outline:0; &#125; IE8及以下不支持Placeholder解决方案（基于JQ）1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt; &lt;html&gt; &lt;header&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; form &#123;margin:50px;&#125; input &#123;display:block;margin:0 0 6px 0;&#125; &lt;/style&gt; &lt;/header&gt; &lt;body&gt; &lt;form&gt; 用户名：&lt;input name=\"name\" placeholder=\"请输入用户名\"/&gt; 密码：&lt;input name=\"password\" placeholder=\"请输入登陆密码\"/&gt; &lt;/form&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; function placeholderSupport() &#123; // 判断浏览器是否支持 placeholder return 'placeholder' in document.createElement('input'); &#125; if(!placeholderSupport())&#123; $(document).on('focus', '[placeholder]',function() &#123; var input = $(this); if (input.val() == input.attr('placeholder')) &#123; input.val(''); input.removeClass('placeholder'); &#125; &#125;); $(document).on('blur', '[placeholder]',function() &#123; var input = $(this); if (input.val() == '' || input.val() == input.attr('placeholder')) &#123; input.addClass('placeholder'); input.val(input.attr('placeholder')); &#125; &#125;); $('[placeholder]').blur(); &#125;; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 常见CSS hack不管是什么方法，书写的顺序都是Firefox的写在前面，IE7的写在中间，IE6的写在最后（1）方式一 条件注释法 只在IE下生效 123&lt;!--[if IE]&gt; 这段文字只在IE浏览器显示 &lt;![endif]--&gt; 只在IE6下生效 123&lt;!--[if IE 6]&gt; 这段文字只在IE6浏览器显示 &lt;![endif]--&gt; 只在IE6以上版本生效 123&lt;!--[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示 &lt;![endif]--&gt; 只在IE8上不生效 123&lt;!--[if ! IE 8]&gt; 这段文字在非IE8浏览器显示 &lt;![endif]--&gt; 非IE浏览器生效 123&lt;!--[if !IE]&gt; 这段文字只在非IE浏览器显示 &lt;![endif]--&gt; （2）方式二 类内属性前缀法 在标准模式中： “-″减号是IE6专有的hack “\\9″ IE6/IE7/IE8/IE9/IE10都生效 “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack IE6能识别 *，但不能识别 !important IE7能识别 *，也能识别!important FF不能识别 *，但能识别!important,下划线_ IE6支持下划线 IE7和firefox均不支持下划线 （3）CSS hack方式三：选择器前缀法 12345678*html //*前缀只对IE6生效 *+html //*+前缀只对IE7生效 @media screen\\9&#123;...&#125; //只对IE6/7生效 @media \\0screen &#123;body &#123; background: red; &#125;&#125; //只对IE8有效 @media \\0screen\\,screen\\9&#123;body &#123; background: blue; &#125;&#125; //只对IE6/7/8有效 @media screen\\0 &#123;body &#123; background: green; &#125;&#125; //只对IE8/9/10有效 @media screen and (min-width:0\\0) &#123;body &#123; background: gray; &#125;&#125; //只对IE9/10有效 @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; //只对IE10有效等等 以: “ #demo {width:100px;} “为例; 1234#demo &#123;width:100px;&#125; /*被FIREFOX,IE6,IE7执行.*/ *html #demo &#123;width:120px;&#125; /*会被IE6执行,之前的定义会被后来的覆盖,所以#demo的宽度在IE6就为120px; */ *+html #demo &#123;width:130px;&#125; /*会被IE7执行*/ 所以最后,#demo的宽度在三个浏览器的解释为: FIREFOX:100px; ie6:120px; ie7:130px; IE8 最新css hack： 1234\"\\9\" 例:\"border:1px\\9;\" //这里的\"\\9\"可以区别所有IE和FireFox.（只针对IE9 Hack） \"\\0\" //IE8识别，--&gt;IE6、IE7不能. \"*\" //IE6、IE7可以识别.--&gt;IE8、FireFox不能. \"_\" //IE6可以识别\"_\",--&gt;IE7、IE8、FireFox不能. Placeholder源自网上资料，点击标题即进入原网址，本人新手，没怎么用过hack，从百度百科整理一部分，作为以后查询方便，如果有什么问题，希望大神多多指点。","categories":[{"name":"前端","slug":"前端","permalink":"http:\\\\hexin.life/categories/前端/"}],"tags":[{"name":"CSS学习笔记","slug":"CSS学习笔记","permalink":"http:\\\\hexin.life/tags/CSS学习笔记/"}]},{"title":"HEXO+GitHub搭建个人博客","slug":"title-1","date":"2017-03-28T15:15:03.000Z","updated":"2017-06-06T09:25:34.820Z","comments":true,"path":"2017/03/28/title-1/","link":"","permalink":"http:\\\\hexin.life/2017/03/28/title-1/","excerpt":"","text":"白日做的梦要靠自己追 一直想有一个自己的博客，前段时间看到HEXO+GitHub傻瓜式搭建，就利用周末花了俩天时间搭建了一个自己的博客。花俩天时间是因为走了太多弯路~搞了太多错误，在这里把流程梳理一下，希望大家不要像我一样走弯路，顺便填入第一篇博客0.0，没有基础的同学也可以利用它搭建自己的博客，我觉得博客不一定要写技术，用来当做自己的私人空间也是很不错的。这里特别感谢Chasen’s ，帮我解决了好多问题。 关于HEXO hexo是一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到 github pages 上，并且他可以使用 markdown 来编写文章，十分方便。 搭建前环境准备安装Node.js进入官网，他会自动提取你的电脑型号，有俩个版本下载，左边的是稳定版，右边的是一直更新的前沿版，我们这里随便选择一个就好了，我个人选择了右边的 直接下载即可，只有13MB大小，然后一路默认安装就好了 安装好以后按 win+r 打开运行输入CMD（开始栏输入CMD也一样） 1输入 node -v 输出版本号即安装成功，我这里是v7.6.0版本 接下来安装git同上进入git 然后点击下载然后默认安装即可（30MB左右），安装好以后右键会有 git gui heregit bush here 不懂git命令也没关系，跟着命令走就可以了，但是学习会对开发很有帮助的，推荐几个网址吧： Git-Reference(官网首选,当然是英文的) git-简易指南（中文简易指南，基本命令够用了） git-常用的基础命令 然后是编辑器Sublime Text（多选） VS Code 微软新发编辑器，虽然是新发，但是功能异常强大Atom 由GitHub打造的属于“ 21 ” 世纪的代码编辑器Notepad++ 一款强大的编辑器 我这里用的是sublime text3，很有程序员风格的编辑器，很多插件与快捷键，特别好用，推荐一下。（中文支持不太好，用习惯就好了）。不用sublime也可以，如果熟悉vim的话可以直接用vim编辑 注册github 对于没有GitHub的同学，在这里申请一个GitHub账号吧，这个很简单，直接注册，邮箱验证就好了。 申请好以后新建一个自己的仓库 这里注意上面俩个箭头， 命名必须要一致，后面的名字要以 github.io 结尾 我当初就因为这里搞错了，导致一直到下面的步骤得重新来，这里先把hexo与github联系起来再说 把git与你的github联系起来 右键git bush here 输入命令绑定你的邮箱和名字，这里是我的~替换成自己的即可 接下来生成秘钥1ssh-keygen -t rsa -C \"XXX@XXX.com\" 这里C是大写！！！ 如图然后连续按回车即可然后在#user_id/.ssh目录下会生成两个文件，id_rsa.pub 和 id_rsa. 利用编辑器打开rsa文件，将里面的内容copy，复制在github，在SSH设置页面添加刚才的SSH文件也就是id_rsa.pub的内容即可。 这里会验证一下github的密码 最后来验证一下：1ssh -T git@github.com 如果成功他让你输入yes然后会返回一个成功的信息 安装hexo 不要着急，马上就可以看到属于你的博客了~ 1npm install hexo-cli -g 然后可以利用 Git 一路 cd 到 hexo 的安装目录，或者进去目录，右键 git bush here 即可（hexo init 的文件夹必须为空文件夹） 目录初始化完毕后，在根目录执行下面命令安装提交的命令。1npm install hexo-deployer-git --save-dev 然后依次执行 hexo init # 初始化 hexo g # 完整命令为hexo generate，生成静态文件 hexo s #完整命令为hexo server，打开本地服务 日后方便提交和防止出错 hexo clean #清理临时文件 hexo d -g #快速生成并提交 打开本地服务，这时候打开浏览器输入 http://localhost:4000 看看你博客页面吧~官方默认会有一篇 hello world，当然 ，现在还只是本地的。只有你自己能看到 将静态页面提交到github 此时就用到了编辑器，打开_config.yml文件，直接拖入编辑器即可自行修改 没有编辑器的同学， 可以cd(进入的意思)到hexo的文件夹下，输入 vim _config.yml 然后直接移动下图的位置，按键盘“ a ”，来插入文本，然后就可以修改了，修改完之后按 ESC ，然后按“ Shif ” 加 “ ：”，输入“ wq ”，意思是保存加退出，如果直接退出就输入“ q ”即可。 然后修改如下：将repo后面的内容改成自己的(没有独立新建分支的话branch可以不写) 1234deploy: type: git repo: git@github.com:yourself/yourself.github.io.git branch: master 提交到 github1hexo d -g #组合命令，命令等同于hexo g 再 hexo d 这时候 github 已经有了你提交的内容( public 文件夹下的内容 ), 然后输入你开始的 github 仓库名字，例如 *.github.io 就可以看到你的博客页面了… 关于主题安装主题有好多种，这里我推荐NEXT,简洁，大方，支持多语言，一句代码即可下载NEXT最新版，如果需要其他的可以上官网查找喜欢的，添加方式是一样的。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后打开 _config.yml文件，如图找到theme修改为next即可 我这里推荐一下yilia。更多好看主题可以去官网搜寻（也可以自己写哦~）。 关于文章发布1hexo new \"title\" // hexo new \"中文标题\" 注意这里如果发布文章是中文的话，最好标题中出现中文：hexo new “中文标题” （不然可能会出现文章乱码）自动生成md文件在 source/_post 下，也可以自己创建为 .md ，注意编码格式用 UTF-8 同样是防止乱码。 然后打开你的 title-n.md 文件编写文章就可以了，文章需要是 markdown 格式，可以用 markdown 格式的编辑器编写，也可以找在线的 markdown 编辑器，例如 CSDN ，马克飞象等等…可以离线使用，支持导出为 MD ，HTML 格式，很方便。关于添加图片，我推荐极简图床，简单方便。 hexo 常用命令( # 后为注释 ) hexo init # 初始化hexo clean # 清理临时文件hexo g # 完整命令为 hexo generate ，生成静态文件hexo s # 完整命令为 hexo server ，打开本地服务hexo d # 完整命令为 hexo deploy ，用于将本地文件发布到 github 上hexo new “postName” # 新建文章hexo new page “pageName” # 新建页面hexo help # 帮助 有什么建议或者改正，希望大家在下面留言，期望同大家共同交流，进步。 另外推荐几篇大神的 blog ： hexo 系列教程 HEXO 官方文档 Hexo 作者博客 hexo 你的博客|不如 使用 hexo 搭建个人博客 极客学院提供的中文文档 帮了我很大忙的 Chasen’s hexo + github 搭建过程总结 手把手教你使用 hexo+github 搭建个人博客 搭建一个免费的，无限流量的 blog（阮一峰） 相信你所相信的，坚持你所坚持的","categories":[{"name":"hexo","slug":"hexo","permalink":"http:\\\\hexin.life/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http:\\\\hexin.life/tags/hexo/"}]}]}