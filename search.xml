<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试题整理]]></title>
    <url>%2F2017%2F07%2F29%2Ftitle-21%2F</url>
    <content type="text"><![CDATA[基础知识使用 typeof 能得到哪些基础类型 undefined boolean Number String Object =&gt; null, object, array Function何时使用 === 何时使用 == 需要判断类型是否相等时使用全等(===) 不需要判断类型是否相等，即需要隐式类型转换的时候使用 ==window.onload 和 DOMContentLoaded 的区别window.onload window.onload 需要等到全部的资源加载完成才会触发，不能够编写多个，编写多个时只会执行最后一个,该方法可以绑定到任意元素上123456789101112&lt;script&gt; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 1) &#125; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 2) &#125; window.onload = function() &#123; console.log(&apos;DOM READY&apos;, 3) &#125; //DOM READY 3 &lt;/script&gt; DOMContentLoaded (HTML5) DOMContentLoaded 类似于 jQuery 的$(document).ready(),页面文档（DOM）完全加载并解析完毕之后触发，不会等图片，iframe, css 等资源加载完成。 如果多次使用，会按顺序依次执行相应任务 12345678910111213141516171819202122&lt;body&gt; &lt;script&gt; document.addEventListener("DOMContentLoaded", function (event) &#123; alert("DOM ready1"); &#125;); document.addEventListener("DOMContentLoaded", function (event) &#123; alert("DOM ready2"); &#125;); &lt;/script&gt; &lt;script&gt; document.addEventListener("DOMContentLoaded", function (event) &#123; alert("DOM ready3"); &#125;); document.addEventListener("DOMContentLoaded", function (event) &#123; alert("DOM ready4"); &#125;);// DOM ready1// DOM ready2// DOM ready3// DOM ready4 &lt;/script&gt;&lt;/body&gt; H5之前使用document.onreadystatechange 事件并手动判断document.readyState == ‘complete’ 来代替。 document.readyState / readtstatechange用来表示 DOM 的加载状态，该属性值发生变化时会触发 readtstatechange 事件。有三种取值： loading: DOM 加载中 interactive: DOM 就绪但资源仍在加载中 compelte : DOM 加载完成 由于 IE8 支持 document.readState 属性,因此在 IE8 中常常用来做 DOMContentLoaded 的降级 (fallback) 注意IE8以前的IE不支持document.readyState属性。 可以执行 document.documentElement.doScroll(“left”)， 当DOM未就绪时执行该方法会抛出错误，以此检测DOM是否就绪。 jQueryjQuery也提供了三种方法载入页面事件 $(document).ready(callback)：DOM就绪时执行回调函数，返回值为 docuument 的jQuery集合 $(function() {})：常用写法，返回和参数同上 $(window).load()：当 DOM 完全加载完毕时，页面渲染完成即图片等资源加载完成时触发.ready() 的实现12345678910if ( document.readyState === "complete" || ( document.readyState !== "loading" &amp;&amp; !document.documentElement.doScroll ) ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready window.setTimeout( jQuery.ready );&#125; else &#123; // Use the handy event callback document.addEventListener( "DOMContentLoaded", completed ); // A fallback to window.onload, that will always work window.addEventListener( "load", completed );&#125; 参考 兼容所有浏览器的 DOM 载入事件 用 JS创建 10个 标签，点击弹出对应序号1234567891011121314151617181920212223(function() &#123; let body = document.body; for (let i = 0; i &lt; 10; i++) &#123; let a = document.createElement('a'); a.textContent = `$&#123;i&#125;`; a.style.cssText = 'margin: 5px;' + 'color: #363636;' + 'font-size: 16px'; body.appendChild(a); &#125; let ac = document.getElementsByTagName('a'); //console.log(ac) for (let i = 0; i &lt; 10; i++) &#123; ac[i].onclick = function() &#123; alert(i) &#125; // ac[i].addEventListener('click', function() &#123; // alert(ac[i].textContent) // &#125;) &#125; &#125;)() 简述如何实现一个模块加载器，实现类似 requirejs 的基本功能JavaScript实现数组的随机排序12345678910111213141516171819// 数组随机排序 var arr = [11, 22, 33, 44, 55, 66, 77, 88, 99, 100]; let len = arr.length; function RandomArray(arr) &#123; if (arr.length == 1) &#123; return arr; &#125; for (let i = 0; i &lt; len; i++) &#123; let random = Math.floor(Math.random() * len); arr.push(arr[random]); arr.splice(random, 1); &#125; console.log(arr); return arr; &#125; RandomArray(arr); 更多实现： 数组元素随机化排序算法实现 数组随机排序 Fisher–Yates shuffle 洗牌算法实现数组的去重ES512345678910111213141516171819202122232425262728293031323334var arr = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];function duplicatesWithString(arr) &#123; var newArr = []; var tmpArr = []; arr.forEach(function(val) &#123; var key = (typeof val) + val; if(!tmpArr[key]) &#123; //如果为 undefined 就进入循环 tmpArr[key] = true; //设置为 true 表示已经存在该数字 newArr.push(val) &#125; &#125;) return newArr;&#125;duplicatesWithString(arr); // =&gt; [1, &quot;1&quot;, 2, 3, 4, &quot;5&quot;, 5]/******************************///如果想去掉字符串function duplicatesNoString(arr) &#123; var newArr = []; var tmpArr = []; arr.forEach(function(val) &#123; if(typeof val !== &apos;string&apos;) &#123; if(!tmpArr[val]) &#123; //如果为 undefined 就进入循环 tmpArr[val] = true; //设置为 true 表示已经存在该数字 newArr.push(val); &#125; &#125; &#125;) return newArr;&#125;duplicatesNoString(arr) ES6ES6中新增 set 数据结构 set 中不能添加重复元素，如：123456var mySet = new Set();mySet.add(1); // Set &#123; 1 &#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add(5); // Set &#123; 1, 5 &#125;mySet.add(&apos;some text&apos;); // Set &#123; 1, 5, &apos;some text&apos; &#125; 因此我们可利用这个特性 123let arr1 = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];let set = new Set(arr1);console.log(set) // =&gt;&#123;1, &quot;1&quot;, 2, 3, 4,&quot;5&quot;, 5&#125; ES6中Array新增了一个静态方法Array.from，可以把类似数组的对象转换为数组(如通过 QuerySelectAll 得到的 Node List) 123let arr2 = [1, &apos;1&apos;, 1, 2, 3, 2, 4, &apos;5&apos;, 5];let array = Array.from(new Set(arr2));console.log(array) // =&gt;[1, &quot;1&quot;, 2, 3, 4, &quot;5&quot;, 5] 参考一行代码实现数组去重（ES6） 实现一个函数，输入 123456789 输出 123，465，78912345678910111213function cal(arr) &#123; var newArr = []; var arr = typeof arr === &apos;string&apos; ? arr : arr.toString(); arr = arr.split(&apos;&apos;); arr.forEach(function(value, index) &#123; if(index % 3 === 0 &amp;&amp; index != 0) &#123; newArr.push(&apos;,&apos;) &#125; newArr.push(arr[index]); &#125;) return newArr.join(&apos;&apos;); &#125;// 判断为三则push进新的数组 CSS 知识Node功能类实现联动放大镜]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的乘法]]></title>
    <url>%2F2017%2F07%2F29%2Ftitle-20%2F</url>
    <content type="text"><![CDATA[创建一个n+1的空数组，调用join方法。12345String.prototype.times = function(n) &#123;//IE6 530-640 FF3 400~550 IE8 840 ~1110 chrome 600~1000 return (new Array(n+1)).join(this);&#125;;``` 2. 创建一个对象，拥有length属性，然后利用call()方法去调用数组原型的join方法。这样就不用创建数组了。 String.prototype.times = function(n) {//IE6 570~600 FF3 320~430 chrome 550~900 IE8 422~490 return Array.prototype.join.call({length:n+1}, this);};123. 它先把Array.prototype.join与对象缓存起来，这样每次就不用从Array的原型查找join方法与创建对象。 String.prototype.times = (function(){//IE6 500~600 FF3 322~390 chrome 581~900 IE8 430~500 var join = Array.prototype.join,//利用闭包，每次的结果都非常不稳定，让浏览器无法进行优化 obj = { }; return function(n) { obj.length = n + 1; return join.call(obj, this); }})();``` 字符串的乘法-司徒正美]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS练习之--模拟call_apply]]></title>
    <url>%2F2017%2F07%2F29%2Ftitle-19%2F</url>
    <content type="text"><![CDATA[apply 和 call在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。例1；12345678910111213var jaw = &#123; name: &apos;jaw&apos;, sayHello: function(age) &#123; console.log(&apos;hello i am &apos; + this.name + &quot; i&apos;m &quot; + age + &apos; years old &apos;) &#125; &#125;;var liu = &#123; name: &apos;liu&apos; &#125;;jaw.sayHello(22); // hello i am jaw i&apos;m 22 years oldjaw.sayHello.apply(liu, [24]); //hello i am liu i&apos;m 24 years old jaw.sayHello.call(liu, 23); //hello i am liu i&apos;m 23 years old 例2：12345678function a()&#123; y=function()&#123; x=2;&#125;; return function()&#123; var x=3;y();console.log(this.x)&#125;.apply(this, arguments)&#125; a(); //2 两个方法都使用了对象本身作为第一个参数。 两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入， call则作为call的参数传入（从第二个参数开始）。 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 通过 call() 或 apply() 方法你可以设置 this 的值, 且作为已存在对象的新方法调用。 apply 模拟实现1234567891011121314151617181920212223242526272829303132Function.prototype.applyOne = function (context) &#123; var context = context || window; //如果没有参数时指向window var args = arguments[1]; //获取传入的数组 var fn = testSymbol(context); context[fn] = this; //fn属性不存在 if(args == void 0) &#123; //没有参数即直接运行 return context[fn](); &#125; var fnStr = &apos;context[fn](&apos;; for (var i = 0; i &lt; args.length; i++) &#123; fnStr += i == args.length - 1 ? args[i] : args[i] + &apos;,&apos;; &#125;; fnStr += &apos;)&apos;; //得到context[fn](arg1,arg2,arg3....) var returnValue = eval(fnStr); // delete context[fn]; //删除这个属性 return returnValue;&#125;//简单模拟es6的Symbol保证属性的唯一性function testSymbol(obj) &#123; var unquie_obj = &apos;00&apos; + Math.random(); if (obj.hasOwnProperty(unquie_obj)) &#123; arguments.callee(obj); &#125; else &#123; return unquie_obj; &#125;&#125; 这里对 call 进行模拟实现1234//callFunction.prototype.callOne = function (context) &#123; return this.applyOne(([].shift.applyOne(arguments)),arguments); //将参数依次弹出即可&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 表单编码 enctype]]></title>
    <url>%2F2017%2F07%2F27%2Ftitle-18%2F</url>
    <content type="text"><![CDATA[在web开发中最常见的莫过于GET和POST，其中 GET 一般将参数编码在 url 中（HTTP header）来传递数据； 而POST或PUT数据必须放在消息主体（entity-body）中，这样的数据便是HTTP表单，表单数据的编码方式应在 HTTP 头中进行设置（Content-Type header字段），常见的编码方式有（HTTP采用MIME框架，编码方式可以是任何MIME类型）： URLencoded: application/x-www-form-urlencoded Multipart: multipart/form-data JSON: application/json XML: text/xml 纯文本: text/plain 在Web开发中，前三种格式非常常见。HTML中 支持 urlencoded,multipart,plain text，通过 enctype 属性来进行设置。AJAX 中默认的则是 JSON 编码格式。 URLencodedHTML中 标签的enctype属性用来指定表单编码格式，默认为 application/x-www-form-urlencoded，即以下两个表单完全等价。123456&lt;form method='post'&gt; &lt;input type="text" name='title'&gt; &lt;input type="text" name='subtitle'&gt; &lt;input type="submit"&gt;&lt;/form&gt; 123456&lt;form method='post' enctype='application/x-www-form-urlencoded'&gt; &lt;input type="text" name='title'&gt; &lt;input type="text" name='subtitle'&gt; &lt;input type="submit"&gt;&lt;/form&gt; 上述表单将会显示为两个文本框和一个提交按钮。我们在文本框中分别写入test和中国后，点击提交按钮。产生的HTTP请求可能是这样的： 可以打开Chrome控制台的Network标签，找到这次请求，便可以看到下面的信息。 请求头（这里只给出了Content-Type字段）：12POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded 请求体： 1title=test&amp;subtitle=%E4%B8%AD%E5%9B%BD 这里你看到的%E4%B8%AD%E5%9B%BD即是中国按照base64编码（url通用的编码方式）后的结果。可以在Chrome Console中通过decodeURI(‘%E4%B8%AD%E5%9B%BD’)来解码。 Multipartmultipart编码方式则需要设置enctype为multipart/form-data。 12345&lt;form method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="title" value="harttle"&gt; &lt;input type="file" name="avatar"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 这里我们还设置了的默认值为harttle。该表单将会显示为一个文本框、一个文件按钮、一个提交按钮。然后我们选择一个文件：chrome.png，点击表单提交后产生的请求可能是这样的： 请求头：12POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA 请求体：12345678910------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;title&quot;harttle------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;chrome.png&quot;Content-Type: image/png ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这便是一个multipart编码的表单。Content-Type中还包含了boundary的定义，它用来分隔请求体中的每个字段。正是这一机制，使得请求体中可以包含二进制文件（当然文件中不能包含boundary）。 除了application/x-www-form-urlencoded和multipart/form-data，HTML的还支持text/plain。此外，如果想提交其他编码类型的表单，必须通过AJAX技术，接下来我们介绍一个常用的JSON数据的提交。 JSON从JavaScript中提交JSON数据真是再方便不过了，jquery、angularJS等框架都封装了更好用的AJAX方法。例如：1234$.post(&apos;/xxx&apos;, &#123; title: &apos;test&apos;, content: [1,2,3] &#125;); 该JavaScript执行后可能生成如下的HTTP请求： 请求头：12POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8 请求体：1&#123;&quot;title&quot;:&quot;test&quot;,&quot;content&quot;:[1,2,3]&#125; XML请求头：12POST http://www.example.com HTTP/1.1Content-Type: text/xml 请求体：12345678&lt;!--?xml version=&quot;1.0&quot;?--&gt;&lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt;&lt;/methodcall&gt; 转载来自： http://harttle.com/2016/04/11/http-form-encoding.html]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式学习]]></title>
    <url>%2F2017%2F07%2F17%2Ftitle-17%2F</url>
    <content type="text"><![CDATA[为了方便查询和学习，这里对正则表达式做一个整理这里推荐一个正则练习的网站 , 将晦涩的正则表达式用图形描述出来 RegExper 像这个样子： 关于正则表达式 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 假设你在一篇英文小说里查找 hi，你可以使用正则表达式hi。这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配 hi, HI, Hi, hI 这四种情况中的任意一种。不幸的是，很多单词里包含hi这两个连续的字符，比如 him hi history high 等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用 \bhi\b 。 使用正则表达式 : 12var reg = /\w+\s/g; var reg = new RegExp("\\w+\\s", "g"); 元字符 . 只能匹配一个字节的字符，不能识别换行符,回车符，行分隔符，段分隔符等换行符,回车符，行分隔符，段分隔符 需要用 s 修饰符来识别， s 修饰符目前处于提案状态 反义字符 转义字符 重复匹配 分组 / 捕获 下面的脚本使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的 $1 , $2 表示第一个和第二个括号的子字符串匹配。 var re = /(\w+)\s(\w+)/;var str = “John Smith”;var newstr = str.replace(re, “$2, $1”);console.log(newstr); 这个表达式输出 “Smith John”。 贪婪 / 惰性 修饰符 ES6 新增修饰符y 修饰符1234567891011let str = 'bb_b=b+bbb++bb';let reg1 = /b+/g; let reg2 = /b+/y; let exec1 = reg1.exec(str);let exec2 = reg2.exec(str);console.log('OneExec:\n' + 'exec1: ' + exec1 + '\texec1: ' + exec2) //bb bbconsole.log('TwoExec:\n' + 'exec1: ' + reg1.exec(str) + '\texec1: ' + reg2.exec(str)) // b null //g 第二次自动匹配下一个位置,而 y 不是console.log(reg1.sticky, reg2.sticky) // 检测是否开启了 y u 修饰符 (unicode)123456789101112131415161718192021222324 var str = '\uD83D\uDC2A'; var reg1 = /^\uD83D/;var reg2 = /^\uD83D/u;console.log('u1: ' + reg1.test(str)) //true //当作俩个字节处理console.log('u2: ' + reg2.test(str)) //false // 当作了一个字节处理console.log(/\u&#123;61&#125;/.test('a')); // false 这里不识别 \u&#123;61&#125; 中的 &#123;61&#125;-&gt; unicode编码 // a 的 unicode编码是 61console.log(/\u&#123;61&#125;/u.test('a')); //trueconsole.log('\u&#123;54564&#125;'); //񔕤console.log('\u&#123;2048&#125;'); //⁈let z1 = '񔕤';let z2 = '⁈';let reg3 = /^.$/;let reg4 = /^.$/u;let test3 = reg3.test(z1);let test4 = reg3.test(z2); // . 只能匹配一个字节的字符，也不能识别换行符等let test5 = reg4.test(z1); //大于俩个字节时，使用 u 修饰符console.log('z1: ' + test3 + ' z2: ' + test4 + ' z1(u): ' + test5); // z1: false z2: true z1(u): true ES6 新增12345678910111213 let reg1 = new RegExp('xyz', 'i'); // round1let reg2 = new RegExp(/xyz/g); // round2 ES5 只能输入一个参数let test1 = reg1.test('xyz123'); //truelet test2 = reg2.test('xyz123'); //true// --&gt; flag es6 新添加，用来获取正则的修饰符 console.log(test1, test2, reg1.flags, reg2.flags)let reg3 = new RegExp(/xyz/g, 'i'); // ES6 允许这种情况输入俩个参数let flag3 = reg3.flags; console.log(flag3); // -&gt; i 这里 i 覆盖了前面的g 使用正则表达式正则表达式属性 lastindex 只在全局匹配时有效例： var myRe = new RegExp(“d(b+)d”, “g”);var myArray = myRe.exec(“cdbbdbsbz”); 通过这些脚本，匹配成功后将返回一个数组并且更新正则表达式的属性，如下表所示。正则表达式执行返回信息 对象 ———— 属性或索引描述 ————– 在例子中对应的值 myArray 匹配到的字符串和所有被记住的子字符串。 [“dbbd”, “bb”] index 在输入的字符串中匹配到的以0开始的索引值。 1 input 初始字符串。 “cdbbdbsbz” [0] 匹配到的所有字符串（并不是匹配后记住的字符串）。注：原文”The last matched characters.”，应该是原版错误。匹配到的最后一个字符索引。 “dbbd” myRe lastIndex 下一个匹配的索引值。（这个属性只有在使用g参数时可用在 通过参数进行高级搜索 一节有详细的描述.) 5 source 模式文本。在正则表达式创建时更新，不执行。 “d(b+)d” 正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search和 split 方法。 方法及描述 : exec &nbsp;&nbsp;一个在 正则 RegExp 中执行查找匹配的 字符串 String 方法，它返回一个数组（未匹配到则返回null）。例： match&nbsp;&nbsp;一个在 字符串 中执行查找匹配的 String 方法，它返回一个数组或者在未匹配到时返回null。例： search&nbsp;&nbsp;一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 test&nbsp;&nbsp;一个在字符串中测试是否匹配的RegExp方法，它返回true或false。例：这里根据测试次数不同， lastindex 值改变，结果会有所不同例： replace&nbsp;&nbsp;一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。例：其中 function 方法： split&nbsp;&nbsp;一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。例： 常见的正则表达式 邮箱： 1/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/ URL 地址： 1/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i 手机号码： 1/^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/ 匹配身份证号： 1/^(^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$)|(^[1-9]\d&#123;5&#125;[1-9]\d&#123;3&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d&#123;4&#125;)|\d&#123;3&#125;[Xx])$)$/ 邮政编码： 1/^[1-9]\d&#123;5&#125;(?!\d)$/ 匹配日期(yyyy-mm-dd)： 1/^[1-2][0-9][0-9][0-9]-[0-1]&#123;0,1&#125;[0-9]-[0-3]&#123;0,1&#125;[0-9]$/ 匹配 HTML 标签： 1/&lt;(\S*?) [^*&gt;.*?&lt;/\1&gt;|&lt;.*?/&gt;/gm 匹配中文字符： 1/[\u4e00-\u9fa5]/gm 只能输入数字： 1/^\d+$/ 只能由英文字母/数字/下划线组成： 1/^\w+$/ 只能英文和数字组成： 1/^[a-z0-9]+$/i 正则表达式学习正则表达式快速参考-MSDN正则表达式-MDN正则表达式30分钟入门教程菜鸟教程-正则表达式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2017%2F07%2F11%2Ftitle-16%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[盒模型 行内元素及块级元素区别]]></title>
    <url>%2F2017%2F07%2F11%2Ftitle-15%2F</url>
    <content type="text"><![CDATA[盒模型.png) 在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性 — 像它的颜色，背景，边框方面 — 和位置是渲染引擎的目标。 在CSS中，使用标准盒模型描述这些矩形盒子中的每一个。这个模型描述了元素所占空间的内容。每个盒子有四个边：外边距边, 边框边, 内填充边 与 内容边。 盒模型 内容区域content area 是包含元素真实内容的区域。它通常包含背景、颜色或者图片等，位于内容边界的内部，它的大小为内容宽度 或 content-box宽及内容高度或content-box高。 如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。 内边距区域 padding area 延伸到包围padding的边框。如果内容区域 content area 设置了背景、颜色或者图片，这些样式将会延伸到 padding 上(译者注：而不仅仅是作用于内容区域)。它位于内边距边界内部, 它的大小为 padding-box 宽与 padding-box 高。 内边距与内容边界之间的空间可以由 padding-top, padding-right, padding-bottom, padding-left 和简写属性 padding 控制。 边框区域 border area 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 border-box 宽和 border-box 高。由 border-width 及简写属性 border控制。 外边距区域 margin area 用空白区域扩展边框区域，以分开相邻的元素。它的大小为 margin-box 的高宽。 外边距区域大小由 margin-top, margin-right, margin-bottom, margin-left 及简写属性 margin 控制。 盒模型宽高计算最终元素的总宽度计算公式是这样的： 总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距 width = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 元素的总高度最终计算公式是这样的： 总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距 height = margin-top + border-top + padding-top + width + padding-bottom + border-bottom + margin-bottom 而IE对宽度的诠释不一样。符合 W3C 标准的浏览器认为一个元素的宽度只等于其 content 的宽度，其余都要额外算。如：123456.example &#123; width: 200px; padding: 10px; border: 5px solid #000; margin: 20px;&#125; 则他最终的宽度应为：宽度 = width + padding 2 + border 2 + margin * 2 = 270px; 而在 IE（低于IE9） 下，最终宽度为：宽度 = width + margin* 2 = 240px; W3C 最后为了解决这个问题，在 CSS3 中加了 box-sizing 这个属性。当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内，和 IE 之前的标准是一样的。 所以，为了避免你同一份 css 在不同浏览器下表现不同，最好加上： 12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125; 浏览器的兼容性问题 一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 IE8 及更早IE版本不支持 填充的宽度和边框的宽度属性设。解决 IE8 及更早版本不兼容问题可以在HTML页面声明 &lt; !DOCTYPE html &gt; 即可。 IE6中浮动双边距因为内联元素没有此问题，所以通过设置 display:inline 解决 行内元素及块级元素HTML (超文本标记语言) 元素大多数都是行内元素或块级元素。 行内元素只占据它对应标签的边框所包含的空间。 块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。行内元素 内容 一般情况下，行内元素只能包含数据和其他行内元素。 格式 行内元素不会以新行开始 块级元素会新起一行。 设置宽度width 无效。 设置高度height 无效，可以通过 line-height 来设置。 设置 margin 只有左右 margin 有效，上下无效。 设置 padding 只有左右 padding 有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的. 如果你要将行内元素变成块级元素，那么就只需要在该标签上加上样式1display:block; 块级元素可以用样式控制其高、宽的值。 若既想让元素在行内显示，又能设置宽高1display: inline-block 行内元素不可以控制宽和高，除非你想将它转变成为块级元素。它的宽和高，是随标签里的内容而变化。 行内元素列表 b, big, i, small, tt abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var a, bdo, br, img, map, object, q, script, span, sub, sup button, input, label, select, textarea 块级元素用法 块级元素只能出现在 元素内 内容 块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。 格式 默认情况下，块级元素会新起一行。 内容模型 一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。块级元素列表 article [HTML5] 文章内容。 aside [HTML5] 伴随内容。 audio [HTML5] 音频播放。 blockquote 块引用。 canvas [HTML5] 绘制图形。 dd 定义列表中定义条目描述。 div 文档分区。 dl 定义列表。 fieldset 表单元素分组。 figcaption [HTML5] 图文信息组标题 figure [HTML5] 图文信息组 (参照 figcaption)。 footer [HTML5] 区段尾或页尾。 form 表单。 h1, h2, h3, h4, h5, h6 标题级别 1-6. header [HTML5] 区段头或页头。 hgroup [HTML5] 标题组。 hr 水平分割线。 noscript 不支持脚本或禁用脚本时显示的内容。 ol 有序列表。 output [HTML5] 表单输出。 p 行。 pre 预格式化文本。 section [HTML5] 一个页面区段。 table 表格。 tfoot 表脚注。 ul 无序列表。 video [HTML5] 视频。 可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object 对象 script - 客户端脚本 参考 CSS块级元素和行内元素-晚晴幽草轩 MDN -行内元素 CSS 最核心的几个概念]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS 缓动(转)]]></title>
    <url>%2F2017%2F07%2F11%2Ftitle-14%2F</url>
    <content type="text"><![CDATA[缓动的基础知识自然界中没有东西是从一点呈线性地移动到另一点。现实中，物体在移动时往往会加速或减速。我们的大脑习惯于期待这种运动，因此在做动画时，应利用此规律。自然的运动会让用户对您的应用感觉更舒适，从而产生更好的总体体验。 缓动使您的动画感觉更自然。 为 UI 元素选择缓出动画。 避免缓入或缓入缓出动画，除非可以使其保持简短；这类动画可能让最终用户觉得很迟钝。 在经典动画中，缓慢开始然后加速的动画术语是“慢入”，快速开始然后减速的动画被称为“慢出”。网络上对于这些动画最常用的术语分别是“缓入”和“缓出”。有时两种动画相组合，称为“缓入缓出”。缓动实际上是使动画不再那么尖锐或生硬的过程。 缓动关键字CSS 变换和动画都允许您选择要为动画使用的缓动类型。您可以使用影响相关动画的缓动（或有时称为 timing）的关键字。还可以完全自定义您的缓动，借此方式更自由地表达应用的个性。 以下是可在 CSS 中使用的一些关键字： linear ease-in ease-out ease-in-out资料来源：CSS 变换，W3C 还可以使用 steps 关键字，它允许您创建具有离散步骤的变换，但上面列出的关键字对于创建感觉自然的动画最有用，并且这绝对是您要的效果。 线性动画 没有任何缓动的动画称为线性动画。线性变换的图形看起来像这样： 随着时间推移，其值以等量增加。采用线性运动时，动画内容往往显得很僵硬，不自然，让用户觉得不协调。一般来说，应避免线性运动。 不管通过 CSS 还是 JavaScript 来编写动画代码，您将发现始终有线性运动的选项。 查看线性动画 要通过 CSS 实现上述效果，代码将类似下面这样：1transition: transform 500ms linear; 缓出动画 缓出使动画在开头处比线性动画更快，还会在结尾处减速。 缓出一般最适合界面，因为开头时快速使动画有反应快的感觉，同时在结尾仍允许有一点自然的减速。查看缓出动画 有很多方法来实现缓出效果，但最简单的方法是 CSS 中的 ease-out 关键字：1transition: transform 500ms ease-out; 缓入动画 缓入动画开头慢结尾快，与缓出动画正好相反。 这种动画像沉重的石头掉落一样，开始时很慢，然后快速地重重撞击地面，突然沉寂下来。 但是，从交互的角度来看，缓入可能让人感觉有点不寻常，因为结尾很突然；在现实中移动的物体往往是减速，而不是突然停止。缓入还有让人感觉行动迟缓的不利效果，这会对网站或应用的响应速度给人的感觉产生负面影响。 查看缓入动画 要使用缓入动画，与缓出和线性动画类似，可以使用其关键字：1transition: transform 500ms ease-in; 缓入缓出动画 缓入并缓出与汽车加速和减速相似，使用得当时，可以实现比单纯缓出更生动的效果。 由于缓入开头让动画有迟钝感，因此动画持续时间不要过长。300-500 毫秒的时间范围通常比较合适，但实际的数量主要取决于项目的感觉。也就是说，由于开头慢、中间快和结尾慢，动画将有更强的对比，可能让用户感到非常满意。查看缓入缓出动画要设置缓入缓出动画，可以使用 ease-in-out CSS 关键字：1transition: transform 500ms ease-in-out;]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制 hexo]]></title>
    <url>%2F2017%2F06%2F06%2Ftitle-11%2F</url>
    <content type="text"><![CDATA[时隔好久，这里对hexo的博客进行一些功能上的拓展 1.七牛云定制空间及绑定到极简图床 对于上传图片个人喜欢极简图床，支持复制粘贴上传，截图然后粘贴用起来贼爽。 极简图窗对于游客每日只有10张图片的上限，开始觉得够用了，但是玩着玩着就没了。不过，他本身提供了七牛云的空间储存。 注册和邮箱验证这里就不赘述了，自行解决吧。 完成之后选择新建仓库名字建议写成小写，他好像是默认小写的。 然后到个人中心找到密钥分别填入 找到仓库下的图片处理位置，绑定的域名使用七牛提供的域名即可 此时就拥有了10G的七牛免费储存空间，极简图床也不限制次数了。慢慢享用吧骚年。 2.HEXO 内容压缩 我这里使用的 NEXT 主题，它在生成 HTML 时由于主题的简洁，形成了大量留白，反而增大了文件大小，使得本来服务器就在国外的网站加载更慢。 1.这里使用当红小生 gulp 进行文件的处理。 HEXO 在根目录下新建 gulpfile.js 文件 我们对文件处理需要用到 gulp 的一些插件 使用 npm install ** –save-dev 来下载这些插件并保存，添加到 package.json 配置项中。 由于 npm 服务器在国外下载较慢，安装淘宝镜像 cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 然后配置 gulpfile.js ,我们知道我们提交博客时，是将静态文件生成到 public 下，然后提交到 github 的。所以我们对文件处理时，就处理这里的静态文件即可。静态文件树形图如下（太长我删减了一部分）： D:. public/ ├─2017 │ ├─03 │ ├─28 │ └─title-1 │ ├─about ├─archives │ ├─2017 │ │ ├─03 │ │ ├ │ │ └─pages │ │ ├─2 │ │ └─3 │ └─pages │ ├─2 │ └─3 ├─assets │ └─js ├─categories │ ├─css │ ├─hexo │ ├─JavaScript │ ├─window │ ├─其他 │ └─前端 ├─css ├─images ├─js │ └─src │ └─schemes ├─lib │ ├─algolia-instant-search │ ├─canvas-nest │ ├─fancybox │ │ └─source │ │ └─helpers │ ├─fastclick │ │ └─lib │ ├─font-awesome │ │ ├─css │ │ └─fonts │ ├─jquery │ ├─jquery_lazyload │ ├─three │ ├─ua-parser-js │ │ └─dist │ └─velocity ├─pages │ ├─2 │ └─3 └─tags ├─css-前端 ├─CSS学习笔记 ├ └─转载 1.因此对文件处理的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 引入插件 const gulp = require('gulp'), Hexo = require('hexo'), pump = require('pump'), clean = require('gulp-clean'), jsmin = require('gulp-jsmin'), // rename = require('gulp-rename'), htmlmin = require('gulp-htmlmin'), imagemin = require('gulp-imagemin'), cleanCSS = require('gulp-clean-css'), imageminSvgo = require('imagemin-svgo'), imageminJpegtran = require('imagemin-jpegtran'), imageminPngquant = require('imagemin-pngquant');// 利用Hexo API 来生成博客内容，效果同在命令行运行：hexo g // generate html with 'hexo generate'var hexo = new Hexo(process.cwd(), &#123;&#125;);gulp.task('generate', function(cb) &#123; hexo.init().then(function() &#123; return hexo.call('generate', &#123; watch: false &#125;); &#125;).then(function() &#123; return hexo.exit(); &#125;).then(function() &#123; return cb() &#125;).catch(function(err) &#123; console.log(err); hexo.exit(err); return cb(err); &#125;)&#125;)//压缩 js 文件gulp.task('jsmin', () =&gt; gulp.src('./public/js/src/**/*.js') .pipe(jsmin()) //.pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest('./public/js')););//压缩 html 文件gulp.task('htmlmin', () =&gt; gulp.src('./public/**/**/**/*.html') .pipe(htmlmin(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest('./public')););// 压缩图片gulp.task('imagemin', () =&gt; gulp.src('./public/images/*') .pipe(imagemin()) .pipe(gulp.dest('./public/images')));imagemin(['./public/images/*.&#123;jpg,png&#125;'], './public/imagess', &#123; plugins: [ imageminJpegtran(), imageminPngquant(&#123;quality: '65-80'&#125;) ]&#125;); imagemin(['./public/images/*.svg'], './public/images', &#123; use: [ imageminSvgo(&#123; plugins: [ &#123;removeViewBox: false&#125; ] &#125;) ]&#125;)//压缩 cssgulp.task('minify-css',() =&gt; gulp.src('./public/css/*.css') .pipe(cleanCSS(&#123;compatibility: 'ie8'&#125;)) .pipe(gulp.dest('./public/css')));//默认任务gulp.task('default',["generate","minify-css","jsmin","htmlmin","imagemin"], function() &#123; console.log('gulp is finished!');&#125;)// gulp.task("watch",function() &#123;// gulp.watch("public/*",["default"]);// &#125;); 之后命令行运行 gulp 即可压缩.因为将生成静态文件的步骤hexo generate 集成到了 gulp 中，所以我们以后可以先 gulp 然后 hexo deploy 提交。 输出如下： 效果如图： 参考： 优化Hexo博客 - 压缩 HTML、CSS、JS、IMG等 3. 添加音乐外链 如果想在看博客的时候听一些喜欢的音乐怎么办呢？ 1. 可以直接在 markdown 中写入 HTML 代码（网易云，虾米均支持外链）1. embed 1&lt;embed src="//music.163.com/style/swf/widget.swf?sid=452986458&amp;type=2&amp;auto=1&amp;width=320&amp;height=66" width="340" height="86" allowNetworking="all"&gt;&lt;/embed&gt; 2. javascript&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xiami.com/widget/player-single?uid=93773004&amp;sid=1769292418&amp;mode=js&quot;&gt;&lt;/script&gt; 3. iframe1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=452986458&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 5. HEXO 的插件 aplayer / dplayer (没有用过就不多说了) hexo-tag-aplayer:https://github.com/grzhan/hexo-tag-aplayer#upstream-issuehexo-tag-dplayer:https://github.com/NextMoe/hexo-tag-dplayer 2. 将音乐框添加到 slideBar 其实方式是一样的，将外链的代码 粘贴到你要显示的地方即可,如图： 1. 点击出现心型特效，及背景线条 1. 心型特效代码 love.js123456789!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:.8,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2.背景特效代码 par.js 12345678 !function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 4. 其他特效如头像旋转等 直接如图： 12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 50%; box-shadow: inset 0 -1px 0 #333sf; -webkit-border-radius: 50%; -moz-border-radius: 50%; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1s ease-out; -moz-transition: -moz-transform 1s ease-out; transition: transform 1s ease-out;&#125; 123456img:hover&#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 做自己喜欢的事情才会有动力]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到 cmder]]></title>
    <url>%2F2017%2F06%2F06%2Ftitle-10%2F</url>
    <content type="text"><![CDATA[咸鱼也得做特别咸的那种 $ 最近电脑受不了了，折腾比较多,对于好多东西装了N次，在这里简单记录一下。$ win 下命令行神器 cmder在 win 下 的命令行神器 cmder，原始 cmd 难看不说，功能也少，这里推荐一下 cmder。可以直接下载 mini 版本，只有 6 mb 大小，完整版本包含了 git 等一堆功能，git 已经安装过了， 这里我就选择了 Mini 版。 安装很简单，直接下载解压即可使用 不过为了方便，我们添加一下环境变量。 即可 Win + R 输入 cmder 唤出。 但是呢，好像还是不够方便，此时我们可以将它添加到我们的鼠标右键，像 git 巴蜀 here 那样。打开 cmder 终端输入下面命令 1Cmder.exe /REGISTER ALL //如果没有权限 则输入 Cmder.exe /REGISTER USER 然后是去除文字重叠， win + alt + p 或者点右下角图标选择设置 setting . 然后将 monospace 前面的对勾去掉即可。 如果习惯 git 里面的 \$ 符号的话。可以打开 D:\cmder_mini\vendor\clink.lua 找到44行左右，将 符号改为 \$ 效果如图： 基本目前所需要的功能差不多就这样。 晚晴幽草轩轩主]]></content>
      <categories>
        <category>window</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[px、em和rem]]></title>
    <url>%2F2017%2F05%2F23%2Ftitle-9%2F</url>
    <content type="text"><![CDATA[再牛逼的梦想也挡不住傻逼似的坚持 ~ –菜鸟教程 &gt; 偶然遇到一个原生JS去除 className 的技巧 Element.className.replace(‘testClassName’, ‘realClassName’);px px : 相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 特点 : IE无法调整那些使用px作为单位的字体大小； 国外的大部分网站能够调整的原因在于其使用了 em 或 rem 作为字体单位； Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。emem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 em的值并不是固定的； em会继承父级元素的字体大小。 123456789101112html &#123; font-size: 20px; /* 20px */&#125; .level-1&#123; font-size: 0.5em; /* 10px */&#125; .level-2&#123; font-size: 2em; /* 20px */&#125;.level-3 &#123; font-size: 0.5em; /* 10px */&#125; rem rem是CSS3新增的一个相对单位（root em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。123456789101112html &#123; font-size: 20px; /* 20px */&#125; .level-1&#123; font-size: 0.5rem; /* 10px */&#125; .level-2&#123; font-size: 2rem; /* 40px */&#125;.level-3 &#123; font-size: 0.5rem; /* 10px */&#125; 对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。1p &#123;font-size:14px; font-size:.875rem;&#125; 注意： 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。px 与 rem 的选择？对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。对于需要适配各种移动设备，则使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。 px、em、rem的区别及介绍-菜鸟教程]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css 前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[copy小插件]]></title>
    <url>%2F2017%2F05%2F06%2Ftitle-8%2F</url>
    <content type="text"><![CDATA[hacker 是擅于解决问题的人 copy小插件昨天舍友在写一个报告的时候，准确的来说是从网上搜罗~然而在 360doc 看到了一个满意的，无奈下载不了，也没法复制粘贴，于是就试了一下。 然后我打开开发者工具(F12)一行代码搞定12//document.getElementsByTagName('body')[0].oncopy = null;document.getElementsByTagName('body')[0].oncopy = ''; //获取body元素的oncpoy事件，直接置空~ 虽然很简单，但是还了一个页面它就失效了，可以再次打开开发者工具，再次置空就行了有更好的办法或者一劳永逸的办法~希望大神指教一下 这是从网上搜到的 chrome 插件的核心代码，制空 copy 事件，并取消页面复制粘贴等冒泡事件123456789101112131415161718192021(function oncopy () &#123; document.getElementsByTagName(body)[0].oncopy = '';&#125;)();document.addEventListener("paste", function (event) &#123; event.stopPropagation();&#125;, true); // true - 事件句柄在捕获阶段执行//for re-enabling 'copy'document.addEventListener("copy", function (event) &#123; event.stopPropagation();&#125;, true);//for re-enabling 'cut'document.addEventListener("cut", function (event) &#123; event.stopPropagation();&#125;, true);//for re-enabling 'right-clicks'document.addEventListener("contextmenu", function(event)&#123; event.stopPropagation();&#125;, true);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS函数闭包]]></title>
    <url>%2F2017%2F04%2F15%2Ftitle-7%2F</url>
    <content type="text"><![CDATA[程序是写给人看的，顺带能在机器上运行 JS循环闭包：应用一html 结构12345 &lt;p&gt;test0&lt;/p&gt;&lt;p&gt;test1&lt;/p&gt;&lt;p&gt;test2&lt;/p&gt;&lt;p&gt;test3&lt;/p&gt;&lt;p&gt;test4&lt;/p&gt; 抛出问题123456789101112131415/* 抛出问题: 此题的目的是想每次点击对应目标时弹出对应的数字下标 0~4,但实际是无论点击哪个目标都会弹出数字5 问题所在: arr 中的每一项的 onclick 均为一个函数实例(Function 对象),这个函数实例也产生了一个闭包域, 这个闭包域引用了外部闭包域的变量,其 function scope 的 closure 对象有个名为 i 的引用, 外部闭包域的私有变量内容发生变化,内部闭包域得到的值自然会发生改变 */ function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = function () &#123; alert(i); //无论点击哪一个均会弹出5 &#125; &#125; &#125; 方法一：12345678910111213解决方法一： 增加若干个对应的闭包域空间( 这里采用的是匿名函数),专门用来存储原先需要引用的内容(下标),不过只限于基本类型(基本类型值传递,对象类型引用传递) function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; (function (j) &#123; arr[i].onclick = function () &#123; alert(j); &#125; &#125;)(i); &#125; &#125; 方法二123456789101112/*思路：将下标作为对象属性(name:"i",value:i的值)添加到每个数组项(p对象)中*/此时当前 p 对象的 i 属性并不是对循环体的 i 变量的引用,而是一个独立 p 对象的属性,属性值在声明的时候就确定了(基本类型的值都是存在栈中的,当有一个基本类型变量声明其等于另一个基本变量时,此时并不是两个基本类型变量都指向一个值,而是各自有各自的值,但值是相等的) function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].i = i; arr[i].onclick = function () &#123; alert(this.i); &#125; &#125; &#125; 方法三1234567891011121314151617/*解决思路:与解决办法一有点相似但却有点不太相似.相似点:同样是增加若干个对应的闭包域空间用来存储下标不同点:解决办法一是在新增的匿名闭包空间内完成事件的绑定,而此例是将事件绑定在新增的匿名函数返回的函数上。此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg*/ function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = (function (j) &#123; return function ()&#123; alert(j); &#125; &#125;)(i); &#125; &#125; 方法四12345678910111213 //思路同方法一： function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (var i = 0; i &lt; arr.length; i++) &#123; (function()&#123; var tmp = i; arr[i].onclick = function () &#123; alert(tmp); &#125; &#125;)(); &#125;&#125; 方法五：12345678910//方法五：es6新语法，let为一个块级作用域 function myClosure() &#123; var arr = document.getElementsByTagName("p"); for (let i = 0; i &lt; arr.length; i++) &#123; arr[i].onclick = function () &#123; alert(i); &#125; &#125; &#125; 非循环闭包：应用一：html 结构12345678910&lt;p id="help"&gt;Helpful notes will appear here&lt;/p&gt; &lt;p&gt;E-mail: &lt;input type="text" id="email" name="email"&gt; &lt;/p&gt; &lt;p&gt;Name: &lt;input type="text" id="name" name="name"&gt; &lt;/p&gt; &lt;p&gt;Age: &lt;input type="text" id="age" name="age"&gt; &lt;/p&gt; 闭包解决 input 框聚焦动态提示1234567891011121314151617181920212223242526272829function showHelp(help) &#123; document.getElementById('help').innerHTML = help; &#125; function makeHelpCallback(help) &#123; return function() &#123; //形成闭包 showHelp(help); &#125;; &#125; function setupHelp() &#123; var helpText = [&#123; 'id': 'email', 'help': 'Your e-mail address' &#125;, &#123; 'id': 'name', 'help': 'Your full name' &#125;, &#123; 'id': 'age', 'help': 'Your age (you must be over 16)' &#125;]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125; &#125; setupHelp(); 应用二html 结构1234567&lt;p&gt;Some paragraph text&lt;/p&gt;&lt;h1&gt;some heading 1 text&lt;/h1&gt;&lt;h2&gt;some heading 2 text&lt;/h2&gt;&lt;a href="#" id="size-12"&gt;12&lt;/a&gt;&lt;a href="#" id="size-14"&gt;14&lt;/a&gt;&lt;a href="#" id="size-16"&gt;16&lt;/a&gt; css123456789101112131415161718192021222324 body &#123; font-family: Helvetica, Arial, sans-serif; font-size: 12px;&#125;h1 &#123; font-size: 1.5em;&#125;h2 &#123; font-size: 1.2em;&#125;```javascript function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;; &#125; var size12 = makeSizer(12); var size14 = makeSizer(14); var size16 = makeSizer(16); document.getElementById('size-12').onclick = size12; document.getElementById('size-14').onclick = size14; document.getElementById('size-16').onclick = size16; From: 闭包-MDN 9种办法解决JS循环闭包面试经典题之for循环]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML 5 Web 存储及WEB应用缓存]]></title>
    <url>%2F2017%2F04%2F15%2Ftitle-6%2F</url>
    <content type="text"><![CDATA[俩种在客户端储存数据的方法 localStorage - 没有时间限制的数据存储 sessionStorage - 针对 session 的数据存储 之前这些都是由cookie完成的，但是cookie不适合大量数据的存储，因为他们由每个服务器的请求来传递，使得cookie速度慢而且效率不高。 在HTML5中，数据不是由每个服务器请求来传递的，而是只有在请求时使用数据，使得在不影响网站性能的情况下存储大量数据。对于不同的网站，sh数据存储于不同的区域，而且一个网站只能访问其自身的数据。HTML5 通过JavaScript来存储和访问数据。 #localStorage 方法 例子对用户访问页面的次数进行计数： 1234567891011&lt;script type="text/javascript"&gt;if (localStorage.pagecount) &#123; localStorage.pagecount=Number(localStorage.pagecount) +1; &#125;else &#123; localStorage.pagecount=1; &#125;document.write("Visits "+ localStorage.pagecount + " time(s).");&lt;/script&gt; sessionStorage 方法 sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 对用户在当前 session 中访问页面的次数进行计数1234567891011&lt;script type="text/javascript"&gt;if (sessionStorage.pagecount) &#123; sessionStorage.pagecount=Number(sessionStorage.pagecount) +1; &#125;else &#123; sessionStorage.pagecount=1; &#125;document.write("Visits "+sessionStorage.pagecount+" time(s) this session.");&lt;/script&gt; HTML 5 应用程序缓存 使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。 什么是应用程序缓存（Application Cache）？ HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势： 离线浏览：用户可在应用离线时使用它们 速度：已缓存资源加载得更快 减少服务器负载：浏览器将只从服务器下载更新过或更改过的资源。 浏览器支持 所有主流浏览器均支持应用程序缓存，除了Internet Explorer。 如需启用应用程序缓存，请在文档的 标签中包含 manifest 属性：1234&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;//something&lt;/html&gt; 每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。manifest 文件的建议的文件扩展名是：”.appcache”。请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。 Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 12NETWORK:login.asp 2.NETWORK ：在此标题下列出的文件需要与服务器的连接，且不会被缓存 12345NETWORK: # NETWORK 小节规定文件 "login.asp" 永远不会被缓存，且离线时是不可用的：login.asp /*------------------------------*/NETWORK:* #可以使用星号来指示所有其他资源/文件都需要因特网连接： 3. FALLBACK：在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 12FALLBACK:/html5/ /404.html #第一个 URI 是资源，第二个是替补。 HTML5 Web应用程序缓存-w3school]]></content>
      <tags>
        <tag>[object Object]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie和session]]></title>
    <url>%2F2017%2F04%2F15%2Ftitle-5%2F</url>
    <content type="text"><![CDATA[相信你所相信的，坚持你所坚持的 cookies HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？即大多都是利用 cookie、session 实现。如浏览器自动保存密码，记住登录状态，网页换肤，新手引导等下次不再提醒功能（我就说我以前换网吧玩总得去禁用那些引导）。比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？因此产生了 cookie 来解决这门问题。 服务器向客户端发送 cookies 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookies 的格式为vlaue = name 格式，且必须包含这部分 浏览器将 cookies 保存 每次浏览器向服务器发送请求都会发送 cookies cookies参数 httpOnly:浏览器下不允许脚本操作document.cookies去更改 cookies,一般情况下设置为 true，可以避免 xss 攻击拿到 cookies path: 表示 cookies 影响到的路径，匹配该路径才会发送 cookies expires、maxAge: 告诉浏览器该 cookies 什么时候过期，采用UTC格式的时间，是 cookies 多久后过期的相对时间。（删除 cookies，在服务端将 maxAge 设为0，或者在客户端将 expires 设为一个过去的时间），如果不设置这俩个选项，会产生 session cookies，session cookies 是即时的，当用户关闭浏览器时，会自动清除，一般用来保存 session 的 session_id.cookies的缺点 大小和数目被确定，浏览器对一个域的cookies有上限要求，且每个 cookies 大小不得超过 4kb。 存在安全性问题，容易被人拦截。（考虑到安全方面，应使用较安全的session） 需要指定域，不能够跨域 cookies 数据太多会影响传输效率，浪费带宽 有些浏览器禁用 cookies 或者部分手机不支持 cookies广告商可以通过cookies了解到用户经常访问哪些网站，进而提供相应的广告等。 session cookies 虽然使用方便,但是 cookies 中所有的数据都可以在客户端被更改，数据很容易被伪造，因此一些重要的数据不能放cookies 中，cookies 数据太多也会影响传输效率，因此产生了 session，session 数据保留在服务器端。(但是当访问增多，会比较占用服务器的性能，考虑到性能方面，减少使用session) 当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中对比取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。此时用户禁用cookies，session也会失效。 但是session并不是完全依赖cookie，服务器可以通过URL重写的方式来传递session_id. ———- &gt; 整理自： cookies 和 session cookies 和 session 的详解 cookie 和 session 的机制与安全 认识cookie与session的区别与应用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个人都需要的中文排版指南（转）]]></title>
    <url>%2F2017%2F04%2F11%2Ftitle-4%2F</url>
    <content type="text"><![CDATA[前几天被朋友吐槽排版太烂了，今天偶然看到这篇文章，然后就转载了过来，由于转载原因可能文章没有原文格式美观，有兴趣请点击链接查看原文。 原文转载自stormzhang 相信你所相信的，坚持你所坚持的 每个人都需要的中文排版指南 之前有不少人在我公众号留言，说看我的排版很舒服，求指导。 我不是一个专业的写字人，我是程序员出身，在写代码的时候有点小洁癖，尽量会把每个细节做到更好，所以我在公众号写作的时候一样会注重每个细节，我认为排版是对写作最基本的要求，所以当我决定要在公众号写作的时候，就非常在意排版，并且一直在改进， 可惜的是，我看到无数不管是写博客还是写公众号的作者，从不会注意自己的排版，有时候看到一篇好的文章，如果排版很烂，会觉得很可惜。 公众号「小道消息」的作者 Fenng曾不止一次强调排版的重要性，对此我也非常认同，任何说不拘小节，注重内容就行了的反驳都是借口，我自己在我的小密圈中也一直强调排版的重要性，很多圈友发布的动态无一排版都太烂，为此，我在小密圈中写下了这么一篇排版指南，真心希望所有的写字人都能注意下自己的排版。 这篇文章适用于所有编辑、作家、撰稿人、公众号作者、博主等，甚至适合所有人，因为人的一生难免避免不了写作。 1. 空格 我每次看到网页上的中文字和英文、数字、符号挤在一起，就会坐立不安，忍不住想在他们之间加个空格。 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」 中英文之间需要加空格 eg. 大家可以搜索公众号 AndroidDeveloper 或者 googdev 关注我。 中文与数字之间需要加空格 eg. 不知不觉，我都快 30 岁了。 数字与单位之间需要加空格 eg. 我有一块 20 TB 的硬盘，鬼知道我是怎么用完的。 完整的英文整句时标点与单词之间需要加空格 eg. Stay hungry, stay foolish. 但是也有一些例外。 度的标志、百分号不加空格 eg. 今天气温有 30° 的高温。 eg. 据统计，关注公众号 AndroidDeveloper 的读者中有 80% 是长得好看的。 全角标点与其他字符之间不加空格 eg. 大家好，我是 stormzhang，请多多关照。 2. 标点 说到标点，不得不说下全角和半角，很多人可能不了解全角和半角的概念，这里顺便介绍下。 全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉字是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 使用全角中文标点，中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 stormzhang。 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. 使用直角引号「我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号」。 eg. 你竟然不知道「帅比张」？ 如果引号再使用引号使用直角双引号。 eg. 我质问他，「你难道忘记『帅比张』了么？」 3. 其他 除以上之外，还有一些其他标准推荐大家使用的。 英文名词首字母尽量大写 eg. Google、Android、Facebook 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone 6s、MacBook Pro 首行不要缩进 这点可能有人不同意，但是我要在这里解释下，在说明之前我们必须弄明白「首行缩进」的目的是什么。 「每段之前空两格」是我们从小学写作文就养成的习惯，也是正式文体的格式要求，其目的是为了区分自然段。 但是像我们现在接触的阅读，都是没有固定的格式要求的，如微信公众号、电子文档等，所以大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 所以，我认为这种应该是最科学的方式，只要没有明确的格式要求，写作的排版无须首行缩进。 最后，你可能会问，以上这些原则是业界标准么？我不敢保证，但是你不妨看下 「Apple 中国官网」、「Microsoft中国官网」、公众号「小道消息」、「MacTalk」等的排版，基本都是使用以上排版标准。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记(Placeholder及CSS_hack)]]></title>
    <url>%2F2017%2F03%2F31%2Ftitle-2%2F</url>
    <content type="text"><![CDATA[相信你所相信的，坚持你所坚持的 IE8以下图片出现蓝色边框123img&#123; border:0; /*或者border:none;*/ &#125; 如何使文本以大写字母开头？1text-transform:capitalize; 强制设置以最新版本IE渲染12&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; //我写的页面在IE8之下全部乱掉了，用这个强制用最新版本的IE渲染 chrome浏览器点击input框时出现边框12//虽然我觉得还挺好看的--! input&#123; outline:none; //outline:0; &#125; IE8及以下不支持Placeholder解决方案（基于JQ）1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt; &lt;html&gt; &lt;header&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; *&#123;margin:0;padding:0;&#125; form &#123;margin:50px;&#125; input &#123;display:block;margin:0 0 6px 0;&#125; &lt;/style&gt; &lt;/header&gt; &lt;body&gt; &lt;form&gt; 用户名：&lt;input name="name" placeholder="请输入用户名"/&gt; 密码：&lt;input name="password" placeholder="请输入登陆密码"/&gt; &lt;/form&gt; &lt;script type="text/javascript" src="jquery-1.11.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; function placeholderSupport() &#123; // 判断浏览器是否支持 placeholder return 'placeholder' in document.createElement('input'); &#125; if(!placeholderSupport())&#123; $(document).on('focus', '[placeholder]',function() &#123; var input = $(this); if (input.val() == input.attr('placeholder')) &#123; input.val(''); input.removeClass('placeholder'); &#125; &#125;); $(document).on('blur', '[placeholder]',function() &#123; var input = $(this); if (input.val() == '' || input.val() == input.attr('placeholder')) &#123; input.addClass('placeholder'); input.val(input.attr('placeholder')); &#125; &#125;); $('[placeholder]').blur(); &#125;; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 常见CSS hack不管是什么方法，书写的顺序都是Firefox的写在前面，IE7的写在中间，IE6的写在最后（1）方式一 条件注释法 只在IE下生效 123&lt;!--[if IE]&gt; 这段文字只在IE浏览器显示 &lt;![endif]--&gt; 只在IE6下生效 123&lt;!--[if IE 6]&gt; 这段文字只在IE6浏览器显示 &lt;![endif]--&gt; 只在IE6以上版本生效 123&lt;!--[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示 &lt;![endif]--&gt; 只在IE8上不生效 123&lt;!--[if ! IE 8]&gt; 这段文字在非IE8浏览器显示 &lt;![endif]--&gt; 非IE浏览器生效 123&lt;!--[if !IE]&gt; 这段文字只在非IE浏览器显示 &lt;![endif]--&gt; （2）方式二 类内属性前缀法 在标准模式中： “-″减号是IE6专有的hack “\9″ IE6/IE7/IE8/IE9/IE10都生效 “\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\9\0″ 只对IE9/IE10生效，是IE9/10的hack IE6能识别 *，但不能识别 !important IE7能识别 *，也能识别!important FF不能识别 *，但能识别!important,下划线_ IE6支持下划线 IE7和firefox均不支持下划线 （3）CSS hack方式三：选择器前缀法 12345678*html //*前缀只对IE6生效 *+html //*+前缀只对IE7生效 @media screen\9&#123;...&#125; //只对IE6/7生效 @media \0screen &#123;body &#123; background: red; &#125;&#125; //只对IE8有效 @media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125; //只对IE6/7/8有效 @media screen\0 &#123;body &#123; background: green; &#125;&#125; //只对IE8/9/10有效 @media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; //只对IE9/10有效 @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; //只对IE10有效等等 以: “ #demo {width:100px;} “为例; 1234#demo &#123;width:100px;&#125; /*被FIREFOX,IE6,IE7执行.*/ *html #demo &#123;width:120px;&#125; /*会被IE6执行,之前的定义会被后来的覆盖,所以#demo的宽度在IE6就为120px; */ *+html #demo &#123;width:130px;&#125; /*会被IE7执行*/ 所以最后,#demo的宽度在三个浏览器的解释为: FIREFOX:100px; ie6:120px; ie7:130px; IE8 最新css hack： 1234"\9" 例:"border:1px\9;" //这里的"\9"可以区别所有IE和FireFox.（只针对IE9 Hack） "\0" //IE8识别，--&gt;IE6、IE7不能. "*" //IE6、IE7可以识别.--&gt;IE8、FireFox不能. "_" //IE6可以识别"_",--&gt;IE7、IE8、FireFox不能. Placeholder源自网上资料，点击标题即进入原网址，本人新手，没怎么用过hack，从百度百科整理一部分，作为以后查询方便，如果有什么问题，希望大神多多指点。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+GitHub搭建个人博客]]></title>
    <url>%2F2017%2F03%2F28%2Ftitle-1%2F</url>
    <content type="text"><![CDATA[白日做的梦要靠自己追 一直想有一个自己的博客，前段时间看到HEXO+GitHub傻瓜式搭建，就利用周末花了俩天时间搭建了一个自己的博客。花俩天时间是因为走了太多弯路~搞了太多错误，在这里把流程梳理一下，希望大家不要像我一样走弯路，顺便填入第一篇博客0.0，没有基础的同学也可以利用它搭建自己的博客，我觉得博客不一定要写技术，用来当做自己的私人空间也是很不错的。这里特别感谢Chasen’s ，帮我解决了好多问题。 关于HEXO hexo是一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到 github pages 上，并且他可以使用 markdown 来编写文章，十分方便。 搭建前环境准备安装Node.js进入官网，他会自动提取你的电脑型号，有俩个版本下载，左边的是稳定版，右边的是一直更新的前沿版，我们这里随便选择一个就好了，我个人选择了右边的 直接下载即可，只有13MB大小，然后一路默认安装就好了 安装好以后按 win+r 打开运行输入CMD（开始栏输入CMD也一样） 1输入 node -v 输出版本号即安装成功，我这里是v7.6.0版本 接下来安装git同上进入git 然后点击下载然后默认安装即可（30MB左右），安装好以后右键会有 git gui heregit bush here 不懂git命令也没关系，跟着命令走就可以了，但是学习会对开发很有帮助的，推荐几个网址吧： Git-Reference(官网首选,当然是英文的) git-简易指南（中文简易指南，基本命令够用了） git-常用的基础命令 然后是编辑器Sublime Text（多选） VS Code 微软新发编辑器，虽然是新发，但是功能异常强大Atom 由GitHub打造的属于“ 21 ” 世纪的代码编辑器Notepad++ 一款强大的编辑器 我这里用的是sublime text3，很有程序员风格的编辑器，很多插件与快捷键，特别好用，推荐一下。（中文支持不太好，用习惯就好了）。不用sublime也可以，如果熟悉vim的话可以直接用vim编辑 注册github 对于没有GitHub的同学，在这里申请一个GitHub账号吧，这个很简单，直接注册，邮箱验证就好了。 申请好以后新建一个自己的仓库 这里注意上面俩个箭头， 命名必须要一致，后面的名字要以 github.io 结尾 我当初就因为这里搞错了，导致一直到下面的步骤得重新来，这里先把hexo与github联系起来再说 把git与你的github联系起来 右键git bush here 输入命令绑定你的邮箱和名字，这里是我的~替换成自己的即可 接下来生成秘钥1ssh-keygen -t rsa -C "XXX@XXX.com" 这里C是大写！！！ 如图然后连续按回车即可然后在#user_id/.ssh目录下会生成两个文件，id_rsa.pub 和 id_rsa. 利用编辑器打开rsa文件，将里面的内容copy，复制在github，在SSH设置页面添加刚才的SSH文件也就是id_rsa.pub的内容即可。 这里会验证一下github的密码 最后来验证一下：1ssh -T git@github.com 如果成功他让你输入yes然后会返回一个成功的信息 安装hexo 不要着急，马上就可以看到属于你的博客了~ 1npm install hexo-cli -g 然后可以利用 Git 一路 cd 到 hexo 的安装目录，或者进去目录，右键 git bush here 即可（hexo init 的文件夹必须为空文件夹） 目录初始化完毕后，在根目录执行下面命令安装提交的命令。1npm install hexo-deployer-git --save-dev 然后依次执行 hexo init # 初始化 hexo g # 完整命令为hexo generate，生成静态文件 hexo s #完整命令为hexo server，打开本地服务 日后方便提交和防止出错 hexo clean #清理临时文件 hexo d -g #快速生成并提交 打开本地服务，这时候打开浏览器输入 http://localhost:4000 看看你博客页面吧~官方默认会有一篇 hello world，当然 ，现在还只是本地的。只有你自己能看到 将静态页面提交到github 此时就用到了编辑器，打开_config.yml文件，直接拖入编辑器即可自行修改 没有编辑器的同学， 可以cd(进入的意思)到hexo的文件夹下，输入 vim _config.yml 然后直接移动下图的位置，按键盘“ a ”，来插入文本，然后就可以修改了，修改完之后按 ESC ，然后按“ Shif ” 加 “ ：”，输入“ wq ”，意思是保存加退出，如果直接退出就输入“ q ”即可。 然后修改如下：将repo后面的内容改成自己的(没有独立新建分支的话branch可以不写) 1234deploy: type: git repo: git@github.com:yourself/yourself.github.io.git branch: master 提交到 github1hexo d -g #组合命令，命令等同于hexo g 再 hexo d 这时候 github 已经有了你提交的内容( public 文件夹下的内容 ), 然后输入你开始的 github 仓库名字，例如 *.github.io 就可以看到你的博客页面了… 关于主题安装主题有好多种，这里我推荐NEXT,简洁，大方，支持多语言，一句代码即可下载NEXT最新版，如果需要其他的可以上官网查找喜欢的，添加方式是一样的。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后打开 _config.yml文件，如图找到theme修改为next即可 我这里推荐一下yilia。更多好看主题可以去官网搜寻（也可以自己写哦~）。 关于文章发布1hexo new "title" // hexo new "中文标题" 注意这里如果发布文章是中文的话，最好标题中出现中文：hexo new “中文标题” （不然可能会出现文章乱码）自动生成md文件在 source/_post 下，也可以自己创建为 .md ，注意编码格式用 UTF-8 同样是防止乱码。 然后打开你的 title-n.md 文件编写文章就可以了，文章需要是 markdown 格式，可以用 markdown 格式的编辑器编写，也可以找在线的 markdown 编辑器，例如 CSDN ，马克飞象等等…可以离线使用，支持导出为 MD ，HTML 格式，很方便。关于添加图片，我推荐极简图床，简单方便。 hexo 常用命令( # 后为注释 ) hexo init # 初始化hexo clean # 清理临时文件hexo g # 完整命令为 hexo generate ，生成静态文件hexo s # 完整命令为 hexo server ，打开本地服务hexo d # 完整命令为 hexo deploy ，用于将本地文件发布到 github 上hexo new “postName” # 新建文章hexo new page “pageName” # 新建页面hexo help # 帮助 有什么建议或者改正，希望大家在下面留言，期望同大家共同交流，进步。 另外推荐几篇大神的 blog ： hexo 系列教程 HEXO 官方文档 Hexo 作者博客 hexo 你的博客|不如 使用 hexo 搭建个人博客 极客学院提供的中文文档 帮了我很大忙的 Chasen’s hexo + github 搭建过程总结 手把手教你使用 hexo+github 搭建个人博客 搭建一个免费的，无限流量的 blog（阮一峰） 相信你所相信的，坚持你所坚持的]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>